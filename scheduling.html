<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Process/Thread Scheduling &mdash; Operating Systems 2021-11-27 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mutual Exclusion" href="mutualexclusion.html" />
    <link rel="prev" title="Files and I/O" href="files-io.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #922247" >
            <a href="index.html" class="icon icon-home"> Operating Systems
          </a>
              <div class="version">
                2021-11-27
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="meta.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Introduction to Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files-io.html">Files and I/O</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Process/Thread Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutualexclusion.html">Mutual Exclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="deadlock.html">Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipc.html">IPC Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernelmm.html">Virtual Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="userlandmm.html">Userland Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">Storage and Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">Implementing Files and Folders</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Storage Research at Loyola</a></li>
<li class="toctree-l1"><a class="reference internal" href="linux_vm.html">Installing a Linux Virtual Machine with VMware</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows_vm.html">Installing a Windows Virtual Machine with VMware</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #922247" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Operating Systems</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Process/Thread Scheduling</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/scheduling.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="process-thread-scheduling">
<h1>Process/Thread Scheduling<a class="headerlink" href="#process-thread-scheduling" title="Permalink to this headline"></a></h1>
<section id="kernel-mode-vs-user-mode">
<h2>Kernel Mode vs. User Mode<a class="headerlink" href="#kernel-mode-vs-user-mode" title="Permalink to this headline"></a></h2>
<p>Kernel Mode</p>
<ul>
<li><p>Can use the full instruction set of the CPU. Including:</p>
<blockquote>
<div><ul class="simple">
<li><p>Enabling / disabling interrupts</p></li>
<li><p>Setting special registers (page table pointer, interrupt table pointer, etc…)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Can modify any location in memory and modify page tables</p></li>
</ul>
<p>User Mode</p>
<ul class="simple">
<li><p>Cannot use privileged instructions.</p></li>
<li><p>Can only modify the memory assigned to the process.</p></li>
</ul>
</section>
<section id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline"></a></h2>
<ul>
<li><p>An interrupt is an event that requires immediate attention from the CPU.</p></li>
<li><p>Procedure for handling interrupts</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Save all registers including the program counter to memory (typically the stack, but not always)</p></li>
<li><p>CPU looks up the interrupt handler on the interrupt vector table and calls the interrupt handler</p></li>
<li><p>Once the interrupt handler is completed, it restores all registers and returns to the program counter. It may optionally retry the instruction that caused the interrupt (in the case of a page fault).</p></li>
<li><p>The program continues execution, not knowing anything has happened</p></li>
</ol>
</div></blockquote>
</li>
<li><p>This algorithm is the same for both hardware and software interrupts.</p></li>
</ul>
</section>
<section id="hardware-interrupts-pc-architecture">
<h2>Hardware Interrupts - PC Architecture<a class="headerlink" href="#hardware-interrupts-pc-architecture" title="Permalink to this headline"></a></h2>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/pc_architecture.png"><img alt="PC Architecture" src="_images/pc_architecture.png" style="height: 500px;" /></a>
</figure>
</section>
<section id="hardware-interrupts-sources">
<h2>Hardware Interrupts - Sources<a class="headerlink" href="#hardware-interrupts-sources" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Southbridge (aka slow stuff) interrupts</p>
<blockquote>
<div><ul class="simple">
<li><p>Early 8088/8086 PCs had a chip called the Intel 8253.</p></li>
<li><p>SMP motherboards include a APIC or Advanced Programmable Interrupt Controller to help route interrupts in multi-processor scenarios</p></li>
<li><p>These chips control interrupts that come from disks, and</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Northbridge (aka fast stuff) Interrupts</p>
<blockquote>
<div><ul class="simple">
<li><p>MMU - page faults (not present, not valid, insufficient permissions)</p></li>
<li><p>ALU - divide by zero exception</p></li>
<li><p>Clock - clock ticks</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="software-interrupts">
<h2>Software Interrupts<a class="headerlink" href="#software-interrupts" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>In operating systems that have separation between kernel and user space, software interrupts are used to implement system calls.</p></li>
<li><p>Hello world in x86 assembly:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>section .text
        global _start
_start:
        mov    edx, len      ; message length
        mov    ecx, msg      ; message to write
        mov    ebx, 1        ; 1 = stdout, the file descriptor
        mov    eax, 4        ; 4 = system call number (sys_write)
        int    0x80          ; software interrupt to call the kernel
section .data
        msg    db   &#39;Hello World!&#39;,0xa
        len    equ  $ - msg
</pre></div>
</div>
<ul class="simple">
<li><p>Software interrupts are much more expensive than making direct function calls through ‘call’ or ‘jmp’ like instructions.</p></li>
<li><p>This cost is worth it in terms of the savings we get in terms of system reliability and security</p></li>
</ul>
</section>
<section id="goals-of-a-process-scheduler">
<h2>Goals of a Process Scheduler<a class="headerlink" href="#goals-of-a-process-scheduler" title="Permalink to this headline"></a></h2>
<ul>
<li><p>The attributes of a process scheduling policy are a combination of the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Fairness: make sure each process gets its fair share of the CPU.</p></li>
<li><p>Efficiency: keep the CPU as busy as possible</p></li>
<li><p>Response time: minimize the response time for interactive users.</p></li>
<li><p>Turnaround: minimize the time batch users must wait for output</p></li>
<li><p>Throughput: maximize the number of jobs processed per hour</p></li>
</ol>
</div></blockquote>
</li>
<li><p>There are no scheduler implementations that are optimal in each of these attributes. There is always a trade-off. Many of these attributes can be contradictory.</p></li>
</ul>
</section>
<section id="types-of-scheduling-strategies">
<h2>Types of Scheduling Strategies<a class="headerlink" href="#types-of-scheduling-strategies" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Preemptive</p></li>
<li><p>round-robin</p></li>
<li><p>priority scheduling</p>
<blockquote>
<div><ul class="simple">
<li><p>shortest job first</p></li>
<li><p>critical path</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Real-time</p>
<blockquote>
<div><ul class="simple">
<li><p>Earliest deadline</p></li>
<li><p>Fixed priority</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Cooperative / event driven</p></li>
<li><p>Run to completion / non-preemptive</p></li>
<li><p>Most modern operating systems use round-robin, preemptive scheduling with support for priorities.</p></li>
</ul>
</section>
<section id="os-support">
<h2>OS Support<a class="headerlink" href="#os-support" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Non-Multitasking</p>
<blockquote>
<div><ul class="simple">
<li><p>CP/M</p></li>
<li><p>MS-DOS</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Cooperative multi-tasking</p>
<blockquote>
<div><ul class="simple">
<li><p>Windows 1.x-3.x</p></li>
<li><p>Mac OS 5 - 9</p></li>
<li><p>NetWare</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Preemptive multi-tasking</p>
<blockquote>
<div><ul class="simple">
<li><p>Minix</p></li>
<li><p>Windows 95-ME, NT4 - 7</p></li>
<li><p>Linux, BSDs</p></li>
<li><p>OS/2</p></li>
<li><p>Mac OSX</p></li>
<li><p>VMS</p></li>
<li><p>Unix</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="types-of-processes-to-schedule">
<h2>Types of Processes to Schedule<a class="headerlink" href="#types-of-processes-to-schedule" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Interactive processes</p>
<blockquote>
<div><ul class="simple">
<li><p>Spend most of their time in the <em>not ready</em> state.</p></li>
<li><p>Wait on either I/O operations to complete or for user interaction</p></li>
</ul>
</div></blockquote>
</li>
<li><p>CPU intensive processes</p>
<blockquote>
<div><ul class="simple">
<li><p>Spend most of their time in the ‘ready’ state.</p></li>
<li><p>Are largely CPU bound.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="preemptive-scheduling-key-terms">
<h2>Preemptive Scheduling Key Terms<a class="headerlink" href="#preemptive-scheduling-key-terms" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><strong>Time Quantum</strong> - the allotted time slice a program is run before a scheduling decision. Typically less than or equal to a clock tick.</p></li>
<li><p><strong>Clock</strong> - one of two triggers for the scheduling algorithm. On most CPUs, the clock ticks at a rate of 50-100Hz. Each clock tick issues a hardware interrupt which permits the operating system to run the scheduler</p></li>
<li><p><strong>Context Switch</strong> - the process by which through a software or hardware interrupt, a process switches from user mode to kernel mode or from kernel mode to user mode</p></li>
</ul>
</section>
<section id="process-states">
<h2>Process states<a class="headerlink" href="#process-states" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>running - currently executing on one or more CPUs</p></li>
<li><p>ready - ready to be executed, but not running</p></li>
<li><p>not ready - not ready to run, currently waiting on an event</p></li>
<li><p>terminated - process has exited and is being cleaned up</p></li>
</ul>
</section>
<section id="choosing-a-quantum">
<h2>Choosing a Quantum<a class="headerlink" href="#choosing-a-quantum" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Variables to consider</p>
<blockquote>
<div><ul class="simple">
<li><p>Context switch / scheduler Overhead</p></li>
<li><p>Quantum Length</p></li>
<li><p>Number of Processes</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Total Overhead: If overhead is 5ms and the quantum is 20ms, then overhead is 20%. If the quantum is 50ms, then the overhead is only 10%</p></li>
<li><p>Average Response Time: If overhead is 5ms, quantum, is 20ms, and 5 active processes exist, the time between runs will be: (overhead + quantum) * (runnable processes - 1) = 100ms. If the quantum is reduced to 10ms, then the time between runs will be: 60ms</p></li>
<li><p>So, the choice of a smaller quantum will make the system more responsive, and a longer quantum will make the system more efficient</p></li>
</ul>
</section>
<section id="context-switches">
<h2>Context Switches<a class="headerlink" href="#context-switches" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A context switch is the process by which a program saves it state to switch to the operating system</p></li>
<li><p>Context switches are caused by software and hardware interrupts</p></li>
</ul>
</section>
<section id="context-switching-how-it-works">
<h2>Context switching - How it works<a class="headerlink" href="#context-switching-how-it-works" title="Permalink to this headline"></a></h2>
<ol class="arabic">
<li><p>Save CPU registers of currently running process into the process table.</p></li>
<li><p>Change the process state to</p>
<ul>
<li><p>Ready</p>
<blockquote>
<div><ul class="simple">
<li><p>if the context switch was caused by a hardware interrupt</p></li>
<li><p>if the context switch was caused by a software interrupt and the kernel
can return immediately (non blocking call)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Not Ready</p>
<blockquote>
<div><ul class="simple">
<li><p>if the context switch was caused by a software interrupt and the
kernel cannot return immediately (blocking call)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
<li><p>Invoke the scheduler to find a ‘ready’ process and change its state to ‘running’</p></li>
<li><p>Restore registers for the new process and switch back to user mode.</p></li>
</ol>
</section>
<section id="degrees-of-preemption">
<h2>Degrees of Preemption<a class="headerlink" href="#degrees-of-preemption" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Different operating systems have different degrees of preemption.</p></li>
<li><p>In simpler operating systems, user-mode tasks can be preempted, but kernel-mode tasks cannot.</p></li>
<li><p>Systems that also allow kernel-mode tasks to be preempted will be more responsive</p></li>
<li><p>Systems with preemptive kernels:</p>
<blockquote>
<div><ul class="simple">
<li><p>Linux since 2.6 (2003)</p></li>
<li><p>Windows NT since NT4 (1996)</p></li>
<li><p>Solaris 2.0 (1991, I think)</p></li>
<li><p>AIX</p></li>
<li><p>Some BSD systems (NetBSD since v5, not sure about others)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The two units that can be considered for scheduling are threads and processes</p></li>
<li><p>Some operating systems only schedule on the process level and do not consider threads separately (Minix does this)</p></li>
<li><p>Other operating systems schedule on a per-thread level (Linux, Windows, OSX)</p></li>
</ul>
</section>
<section id="round-robin-process-scheduling">
<h2>Round - Robin Process Scheduling<a class="headerlink" href="#round-robin-process-scheduling" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Round robin scheduling is the simplest scheduling policy, but not the most efficient</p></li>
<li><p>The operating system maintains two lists:</p>
<blockquote>
<div><ul class="simple">
<li><p>runnable list</p></li>
<li><p>non-runnable list</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The operating system simply runs through the runnable list in order executing each process one at a time. (or N at a time for N-CPUs)</p></li>
</ul>
</section>
<section id="scheduling-with-multiple-queues">
<h2>Scheduling with Multiple Queues<a class="headerlink" href="#scheduling-with-multiple-queues" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Runnable threads are separated into queues based upon:</p></li>
<li><p>Quantum length</p></li>
<li><p>Process / thread priority</p></li>
<li><p>Each queue is then run round-robin</p></li>
<li><p>Algorithm (pseudo):</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread</span> <span class="n">schedule</span><span class="p">(</span><span class="n">thread</span> <span class="n">interruptedThread</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">highest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lowest</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
        <span class="n">Queue</span> <span class="n">runQueue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">interruptedThread</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">runnable</span> <span class="ow">or</span> <span class="n">blocked</span>
        <span class="n">queue</span><span class="p">(</span><span class="n">interruptedThread</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">interruptedThread</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">highest</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lowest</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">queue</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">has</span> <span class="nb">any</span> <span class="n">runnable</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">();</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>
                        <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>What are some problems with this scheduling algorithm?</p></li>
<li><p>What happens if higher priority threads are always runnable?</p></li>
<li><p>How do we give processes that don’t use their entire quantum (I/O bound) more priority?</p></li>
<li><p>Improved Algorithm (pseudo):</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>thread schedule(thread interruptedThread) {
        let highest = 0, lowest = 9;
        Queue runQueue(10);
        if(interruptedThread.quantumUsed « Quantum) {
                interruptedThread.priority = max(interruptedThread.priority+1, highest);
        }
        interruptedThread.state = runnable or blocked
        queue(interruptedThread.priority).enqueue(interruptedThread)
        for(int i = highest; i «= lowest; i++) {
                if(queue(i) has any runnable threads) {
                        thread t = queue.dequeue();
                        t.state = running;
                        t.priority -= 1;
                        if(t.priority != t.basePriority &amp;&amp; t.priority »= lowest) {
                                t.priority = t.basePriority;
                        }
                        return t;
                }
        }
}
</pre></div>
</div>
<ul>
<li><p>The reason that this scheduler is better is because it accomplishes two things:</p>
<blockquote>
<div><ul class="simple">
<li><p>It boosts priority of threads that don’t completely use their allotted quantum (typically I/O bound)</p></li>
<li><p>If a thread is run, then its priority is temporarily decreased. The higher priority a thread is, the more chances it will have to run before it gets to the lowest queue. Also, this ensures that all ready processes will be run at some point.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>There are many variations on this type of scheduling that attempt to fine tune the rate of increase or decrease of thread priority. The most typical enhancement is to increase or decrease the amount of priority change with the number of priority changes.</p></li>
</ul>
</section>
<section id="real-time-schedulers">
<h2>Real-time Schedulers<a class="headerlink" href="#real-time-schedulers" title="Permalink to this headline"></a></h2>
<ul>
<li><p>This is most typically used in real-time operating systems where the most important aspect of a process is not its priority but its deadline to complete a unit of work.</p></li>
<li><p>Attributes of real-time processes:</p>
<blockquote>
<div><ul>
<li><p>Arrival time (some absolute time)</p></li>
<li><p>Deadline (some time relative to the arrival time)</p></li>
<li><p>Execution requirement</p>
<blockquote>
<div><ul class="simple">
<li><p>Time for computation</p></li>
<li><p>Time to complete system calls</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>The goal of a real-time scheduler is to make sure as many processes as possible get their full execution requirement before the deadline.</p>
<blockquote>
<div><ul class="simple">
<li><p>This isn’t always possible (two processes arrive at the same time with 100ms requirements, both with deadlines 120ms away).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>In a real time scheduler, completion of all tasks before deadlines is the most important goal. The next important goal is achieving high CPU utilization.</p></li>
<li><p>Terms:</p>
<blockquote>
<div><ul class="simple">
<li><p>Utilization - the sum of the execution time divided by the arrival rate of the process (entering the runnable state)</p></li>
<li><p>Schedulable - a set of processes is ‘schedulable’ if the utilization of the system is less than 100%</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Example:</p>
<blockquote>
<div><ul class="simple">
<li><p>Pa requires 2 units of time and arrives at t=0,5,10,15,….</p></li>
<li><p>Pb requires 1 unit of time and arrives at t=2,4,6,8,10,….</p></li>
<li><p>Utilization is: 2/5 + 1/2 = 90%. Therefore the system is schedulable.</p></li>
<li><p>If Pc is added and requires 3 units of time and arrives at t=0,5,10,15,…. then utilization is 2/5 + 3/5 + 1/2 = 150% and the system is not schedulable. (at least some processes will miss their deadlines)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/rts_1.png"><img alt="RTS Scheduler Example 1" src="_images/rts_1.png" style="width: 600px;" /></a>
</figure>
</section>
<section id="example-real-world-rts-problem">
<h2>Example Real World RTS Problem<a class="headerlink" href="#example-real-world-rts-problem" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Example problem: Anti-Lock braking system.</p></li>
<li><p>Problem description:</p>
<blockquote>
<div><ul class="simple">
<li><p>Each wheel has a sensor that reports wheel speed every 15ms</p></li>
<li><p>An additional sensor reports vehicle speed every 15ms. Recording values takes 1ms.</p></li>
<li><p>Wheel angular velocity is (wheel speed) / (wheel radius)</p></li>
<li><p>Vehicle angular velocity is (vehicle speed) / (wheel radius)</p></li>
<li><p>Wheel slip is 1 - (wheel angular velocity) / (vehical angular velocity)</p></li>
<li><p>When slip = 1, a wheel is locked up. Ideal slip is 0.2.</p></li>
<li><p>Engineers report that slip can change at a rate of 0.1 per 50ms</p></li>
<li><p>Adjusting anti-lock brakes for all tires takes 6ms.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>What are the scheduling requirements of this system?</p></li>
<li><p>What are the processes?</p></li>
<li><p>What are the arrival rates and deadlines of processes?</p></li>
<li><p>Do we need faster sensors?</p></li>
<li><p>Can we save money by:</p>
<blockquote>
<div><ul class="simple">
<li><p>Getting a slower CPU?</p></li>
<li><p>Getting slower sensors?</p></li>
<li><p>Getting an ABS system that reacts slower?</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="solution-to-example-real-world-rts-problem">
<h2>Solution to Example Real World RTS Problem<a class="headerlink" href="#solution-to-example-real-world-rts-problem" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Sensor[A-D]: Period = 15ms, Requirement = 1ms</p></li>
<li><p>Sensor[V]: Period = 15ms, Requirement = 1ms</p></li>
<li><p>2 samples can be taken and recorded for each tire in a period of 15ms*2+5ms = 35ms (the first recording period overlaps with the second reading so we don’t count it)</p></li>
<li><p>If a problem is found, we can schedule a process to adjust anti-lock brakes which will take 6ms. 35ms + 6ms = 41ms. This is faster than the rate of change in slip of 50ms.</p></li>
<li><p>Is this schedulable? 1/15 + 1/15 + 1/15 + 1/15 + 1/15 + 6/35 = 50.47%. Yes!</p></li>
</ul>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/rts_2.png"><img alt="RTS Example 2" src="_images/rts_2.png" style="width: 800px;" /></a>
</figure>
<ul class="simple">
<li><p>It appears that we also have</p></li>
<li><p>8ms of extra time before our deadline</p></li>
<li><p>25ms of idle CPU time every 42ms</p></li>
<li><p>So, we can save money by using a slower CPU, ABS, and/or sensors.</p></li>
</ul>
</section>
<section id="types-of-real-time-scheduler-implementations">
<h2>Types of Real-Time Scheduler Implementations<a class="headerlink" href="#types-of-real-time-scheduler-implementations" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Earliest deadline first</p>
<blockquote>
<div><ul class="simple">
<li><p>Works with estimates of process runtimes and arrival rates.</p></li>
<li><p>When system utilization is over 100%, which processes miss deadlines is unpredictable</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Fixed priority</p>
<blockquote>
<div><ul class="simple">
<li><p>Gives the highest priority task CPU whenever it is in the ready state.</p></li>
<li><p>If utilization is over 100%, then lower priority tasks will not meet the deadline. This is more predictable and therefore more often favored</p></li>
<li><p>Simpler to implement</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="additional-concerns-in-advanced-scheduler-implementations">
<h2>Additional Concerns in Advanced Scheduler Implementations<a class="headerlink" href="#additional-concerns-in-advanced-scheduler-implementations" title="Permalink to this headline"></a></h2>
<ul>
<li><p>In more advanced operating systems, additional issues are considered in schedulers in addition to priority</p>
<blockquote>
<div><ul class="simple">
<li><p>CPU / Core affinity</p></li>
<li><p>How many pages of the working set of a process are resident</p></li>
<li><p>NUMA</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If a process is scheduled on a given core previously:</p>
<blockquote>
<div><ul class="simple">
<li><p>There is a decent chance that some of its pages are still in L1/L2/L3 cache.</p></li>
<li><p>Scheduling on that CPU again is better than not.</p></li>
<li><p>But, if too many processes are grouped on one CPU, they need to be migrated though.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>NUMA = Non Uniform Memory Access</p>
<blockquote>
<div><ul class="simple">
<li><p>This is common in machines with separate physical CPUs</p></li>
<li><p>Each CPU gets a memory bus to one bank of CPUs.</p></li>
<li><p>This means, that some of the memory is faster for for a given CPU and some memory is slower.</p></li>
<li><p>When choosing a CPU to execute on, where pages are allocated matters.</p></li>
<li><p>Also, when the OS allocates pages, taking into account which NUMA region has been used before and how crowded / busy it is also matters.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="process-priority-and-scheduling-in-linux">
<h2>Process Priority and Scheduling in Linux<a class="headerlink" href="#process-priority-and-scheduling-in-linux" title="Permalink to this headline"></a></h2>
<ul>
<li><p>The Linux scheduler has several available policies:</p>
<blockquote>
<div><ul>
<li><p>Normal policies:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_OTHER</span></code> - round-robin time sharing polic</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_BATCH</span></code> - batch policy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_IDLE</span></code> - for running very low priority background jobs</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Real-time policies:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code> - first-in, first-out  policy</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_RR</span></code> - round-robin</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Scheduling policy is controlled by:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sched_setscheduler(pid_t</span> <span class="pre">pid,</span> <span class="pre">int</span> <span class="pre">policy,</span> <span class="pre">sched_param</span> <span class="pre">*param);</span></code></p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">sched_param</span></code> struct, takes amongst other things, a priority value</p></li>
<li><p>this priority value is only consumed by the real time schedulers</p></li>
<li><p>normal policies make use of <em>nice</em> values</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="linux-real-time-scheduler">
<h2>Linux Real Time Scheduler<a class="headerlink" href="#linux-real-time-scheduler" title="Permalink to this headline"></a></h2>
<ul>
<li><p>In Linux, real-time processes always have priority over non-real time processes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code></p>
<blockquote>
<div><ul>
<li><p>Has one FIFO queue per-priority</p></li>
<li><p>When sched_setscheduler is called, the process goes into the front of the queue.</p></li>
<li><p>If the process is preempted, it keeps its place in the queue.</p></li>
<li><p>If sched_yield is called, then the process moves to the back of the queue.</p></li>
<li><p>Once running, the process will continue running until:</p>
<blockquote>
<div><ul class="simple">
<li><p>A higher priority process becomes runnable</p></li>
<li><p>The process issues an I/O request</p></li>
<li><p>The process calls sched_yield()</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code> processes are prevented from locking the system up by the RLIMIT_RTTIME limit. This is the CPU time limit that a process may take up before issuing a system call. After this soft limit is hit, the process is signaled several time until a hard limit is reached. If the hard limit is reached, the process is killed.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_RR</span></code>:</p>
<blockquote>
<div><ul>
<li><p>Exactly the same as <code class="docutils literal notranslate"><span class="pre">SCHED_FIFO</span></code>, except:</p>
<blockquote>
<div><ul class="simple">
<li><p>each process has a finite quantum.</p></li>
<li><p>if a process is preempted, it moves to the back of the queue</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="linux-preemptive-scheduler">
<h2>Linux Preemptive Scheduler<a class="headerlink" href="#linux-preemptive-scheduler" title="Permalink to this headline"></a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_OTHER</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>This is the default scheduling policy in Linux.</p></li>
<li><p>Uses <em>nice</em> values for prioritization.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_BATCH</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Same as <code class="docutils literal notranslate"><span class="pre">SCHED_OTHER</span></code>, except…</p></li>
<li><p>Notifies scheduler that the process is both non-interactive and not I/O intensive</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCHED_IDLE</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Same as <code class="docutils literal notranslate"><span class="pre">SCHED_OTHER</span></code>, except…</p></li>
<li><p>All processes in this class are always of lower priority than all other processes. This means that if any other process is runnable, these processes do not run.</p></li>
<li><p><em>nice</em> values are ignored completely</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="nice-values">
<h2>Nice Values<a class="headerlink" href="#nice-values" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Common in all Unix schedulers is the use of <em>nice</em> values.</p></li>
<li><p>The nice value is the priority level of a process.</p>
<blockquote>
<div><ul class="simple">
<li><p>The highest priority is -20</p></li>
<li><p>The lowest priority is 19</p></li>
<li><p>The typical default priority is 0.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>When a process calls fork(), the new process inherits the parent’s nice value.</p></li>
<li><p>Non-root processes can increase the nice value</p></li>
<li><p>Only root processes can decrease the nice value</p></li>
<li><p>The effect of the nice value differs between scheduler implementations and is not the only factor taken into account in scheduling decisions</p></li>
</ul>
</section>
<section id="process-scheduling-in-windows">
<h2>Process Scheduling in Windows<a class="headerlink" href="#process-scheduling-in-windows" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Windows has 6 process classes with 7 priorities within each class</p></li>
<li><p>Classes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Idle</p></li>
<li><p>Below Normal</p></li>
<li><p>Normal</p></li>
<li><p>Above Normal</p></li>
<li><p>High</p></li>
<li><p>Realtime</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Below - High:</p>
<blockquote>
<div><ul class="simple">
<li><p>Within a class, processes time-share relative to priority</p></li>
<li><p>Lower classes are not run unless higher classes are not runnable (or there are other idle CPUs)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Idle - only runs if no other process is runnable</p></li>
<li><p>Realtime - always run when runnable, will not be interrupted until the process makes a system call or goes to sleep.</p></li>
<li><p>Process scheduler takes NUMA into account in:</p>
<blockquote>
<div><ul class="simple">
<li><p>XP Professional, Vista, 7</p></li>
<li><p>Server 2003 / 2008 / 2008R2</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Supports more advanced heap management and scheduling on systems with more than 64 CPUs in Server 2008R2 through the use of processor groups</p></li>
<li><p>Multimedia Class Scheduler Service:</p>
<blockquote>
<div><ul class="simple">
<li><p>Creates classes of processes that have a minimum CPU requirement that the OS must meet.</p></li>
<li><p>Typically used to make sure audio, video, etc… are responsive in the presence of higher system loads.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="user-mode-schedulers">
<h2>User-Mode Schedulers<a class="headerlink" href="#user-mode-schedulers" title="Permalink to this headline"></a></h2>
<ul>
<li><p>User-mode schedulers fall into two categories:</p>
<blockquote>
<div><ul class="simple">
<li><p>Per-process: N user threads per 1 process (N threads total)</p></li>
<li><p>Per-thread: N user threads per 1 kernel thread (N*K threads)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Options:</p>
<blockquote>
<div><ul>
<li><p>Windows:</p>
<blockquote>
<div><ul class="simple">
<li><p>UMS Scheduler Component - 64-bit Server 2k8, Win 7</p></li>
<li><p>Fibers</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Linux/Minix</p>
<blockquote>
<div><ul class="simple">
<li><p>GNU Pth</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Custom:</p>
<blockquote>
<div><ul class="simple">
<li><p>Use of setjump, longjmp functions to save / switch stacks</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="user-mode-threads-why">
<h2>User-Mode Threads: Why?<a class="headerlink" href="#user-mode-threads-why" title="Permalink to this headline"></a></h2>
<ul>
<li><p>Useful on systems with no support for kernel threads:</p></li>
<li><p>Minix, Windows 3.x, Mac OS 5-9</p></li>
<li><p>Useful on systems with huge or volatile thread counts:</p>
<blockquote>
<div><ul class="simple">
<li><p>An 8-CPU system with 24-32 active threads that doesn’t create and destroy threads often, works very well.</p></li>
<li><p>An 8-CPU system with 2000 threads will grind to a halt.</p></li>
<li><p>An 8-CPU system with 10 threads, then 120 threads, then 5 threads, will waste a lot of time creating and destroying threads.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Creating and destroying user mode threads is relatively cheap when compared to kernel threads.</p></li>
<li><p>Systems like Erlang or others that create a high number of parallel components benefit greatly from being able to abstract an unlimited number of threads without the actual need for there to literally be that number of threads.</p></li>
</ul>
</section>
<section id="user-mode-threads-why-not">
<h2>User-Mode Threads: Why Not?<a class="headerlink" href="#user-mode-threads-why-not" title="Permalink to this headline"></a></h2>
<ul>
<li><p>User mode threads have a lower degree of parallelism than do kernel mode threads. If you have 10 user threads on one kernel thread, you still are only executing on one CPU</p></li>
<li><p>User mode threads don’t benefit from operating system scheduler advantages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Knowledge about CPU consumption</p></li>
<li><p>Knowledge about memory utilization</p></li>
<li><p>Knowledge about the page table and NUMA configuration</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If one user mode thread locks up, it locks up its entire kernel thread. Other user mode threads on that kernel thread cannot proceed.</p></li>
<li><p>If one user mode thread makes a system call, the user mode threading library or the application must use asynchronous I/O function calls (which are more complex) to maintain responsiveness for other user mode threads. Otherwise the entire kernel thread will block.</p></li>
<li><p>User mode threads do not perform as well as a similar number of kernel threads for number crunching applications (unless the number is » 4 per CPU)</p></li>
<li><p>The reason for this is that kernel threads will have longer quantums than will user mode threads. User mode threads divide the quantum of one kernel mode thread.</p></li>
<li><p>This problem is not as important for interactive, I/O based, or mixed applications.</p></li>
</ul>
</section>
<section id="gnu-pth-user-mode-pthreads">
<h2>GNU - Pth - User Mode Pthreads<a class="headerlink" href="#gnu-pth-user-mode-pthreads" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>GNU Pth maps pretty closely to normal posix threading libraries.</p></li>
<li><p>The use of GNU Pth is probably best illustrated with an example.</p></li>
<li><p>The interesting calls are (pth_accept, pth_write, and pth_sleep).</p></li>
<li><p>Since this program is I/O bound, we need to use asynchronous I/O calls to make sure all threads are responsive.</p></li>
<li><p>This is accomplished with pth_* calls such as pth_write, pth_accept.</p></li>
<li><p>These calls are asynchronous wrappers to normal system calls.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pth.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;netdb.h&gt;</span><span class="cp"></span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">handler</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_arg</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 9</span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">_arg</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">    </span><span class="kt">time_t</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ct</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">    </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">    </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span><span class="w"></span>
<span class="linenos">16</span><span class="w">    </span><span class="n">pth_write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">ct</span><span class="p">));</span><span class="w"></span>
<span class="linenos">17</span><span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">ticker</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_arg</span><span class="p">)</span><span class="w"></span>
<span class="linenos">22</span><span class="p">{</span><span class="w"></span>
<span class="linenos">23</span><span class="w">    </span><span class="kt">time_t</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ct</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">load</span><span class="p">;</span><span class="w"></span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">28</span><span class="w">        </span><span class="n">pth_sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="w">        </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">30</span><span class="w">        </span><span class="n">ct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span><span class="w"></span>
<span class="linenos">31</span><span class="w">        </span><span class="n">ct</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">32</span><span class="w">        </span><span class="n">pth_ctrl</span><span class="p">(</span><span class="n">PTH_CTRL_GETAVLOAD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">load</span><span class="p">);</span><span class="w"></span>
<span class="linenos">33</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ticker: time: %s, average load: %.2f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">,</span><span class="w"> </span><span class="n">load</span><span class="p">);</span><span class="w"></span>
<span class="linenos">34</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">35</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span><span class="p">}</span><span class="w"></span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="linenos">39</span><span class="p">{</span><span class="w"></span>
<span class="linenos">40</span><span class="w">    </span><span class="n">pth_attr_t</span><span class="w"> </span><span class="n">attr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">41</span><span class="w">    </span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">sar</span><span class="p">;</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="k">struct</span> <span class="nc">protoent</span><span class="w"> </span><span class="o">*</span><span class="n">pe</span><span class="p">;</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">peer_addr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">44</span><span class="w">    </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">peer_len</span><span class="p">;</span><span class="w"></span>
<span class="linenos">45</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="n">sw</span><span class="p">;</span><span class="w"></span>
<span class="linenos">46</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">port</span><span class="p">;</span><span class="w"></span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">    </span><span class="n">pth_init</span><span class="p">();</span><span class="w"></span>
<span class="linenos">49</span><span class="w">    </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">50</span><span class="w">    </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span><span class="w"> </span><span class="n">SIG_IGN</span><span class="p">);</span><span class="w"></span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">    </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pth_attr_new</span><span class="p">();</span><span class="w"></span>
<span class="linenos">53</span><span class="w">    </span><span class="n">pth_attr_set</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PTH_ATTR_NAME</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ticker&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">54</span><span class="w">    </span><span class="n">pth_attr_set</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PTH_ATTR_STACK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="linenos">55</span><span class="w">    </span><span class="n">pth_attr_set</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PTH_ATTR_JOINABLE</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span><span class="w"></span>
<span class="linenos">56</span><span class="w">    </span><span class="n">pth_spawn</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">ticker</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">57</span>
<span class="linenos">58</span><span class="w">    </span><span class="n">pe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getprotobyname</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">59</span><span class="w">    </span><span class="n">sa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">p_proto</span><span class="p">);</span><span class="w"></span>
<span class="linenos">60</span><span class="w">    </span><span class="n">sar</span><span class="p">.</span><span class="n">sin_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">;</span><span class="w"></span>
<span class="linenos">61</span><span class="w">    </span><span class="n">sar</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INADDR_ANY</span><span class="p">;</span><span class="w"></span>
<span class="linenos">62</span><span class="w">    </span><span class="n">sar</span><span class="p">.</span><span class="n">sin_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span><span class="w"></span>
<span class="linenos">63</span><span class="w">    </span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sar</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="p">));</span><span class="w"></span>
<span class="linenos">64</span><span class="w">    </span><span class="n">listen</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="linenos">65</span>
<span class="linenos">66</span><span class="w">    </span><span class="n">pth_attr_set</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">PTH_ATTR_NAME</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;handler&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">67</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">68</span><span class="w">        </span><span class="n">sw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pth_accept</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">peer_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">peer_len</span><span class="p">);</span><span class="w"></span>
<span class="linenos">69</span><span class="w">        </span><span class="n">pth_spawn</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sw</span><span class="p">);</span><span class="w"></span>
<span class="linenos">70</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">71</span>
<span class="linenos">72</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">73</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="pthreads-kernel-threads">
<h2>PThreads - Kernel Threads<a class="headerlink" href="#pthreads-kernel-threads" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Most POSIX compliant systems implement a pthreads library.</p></li>
<li><p>In Minix, the PThreads library makes use of a layer on top of pth.</p></li>
<li><p>In Linux, PThreads use the clone() system call to create lightweight processes (aka kernel threads).</p></li>
<li><p>Example</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cm">/* adapted from LLNL pthreads tutorial</span>
<span class="linenos"> 2</span><span class="cm"> * https://computing.llnl.gov/tutorials/pthreads</span>
<span class="linenos"> 3</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span><span class="cp"></span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="linenos"> 7</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="linenos"> 8</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="cp">#define NUM_THREADS     5</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="k">struct</span> <span class="nc">thread_data</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"></span>
<span class="linenos">14</span><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">square</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="p">};</span><span class="w"></span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">thread_data</span><span class="w"> </span><span class="n">thread_data_t</span><span class="p">;</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">PrintHello</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">td_ptr</span><span class="p">)</span><span class="w"></span>
<span class="linenos">22</span><span class="p">{</span><span class="w"></span>
<span class="linenos">23</span><span class="w">    </span><span class="n">thread_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">td</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">thread_data_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">td_ptr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">24</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World! It&#39;s me, thread #%ld!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">td</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span><span class="w"></span>
<span class="linenos">25</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sqr(%ld) = %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">td</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="n">td</span><span class="o">-&gt;</span><span class="n">square</span><span class="p">);</span><span class="w"></span>
<span class="linenos">26</span><span class="w">    </span><span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="p">}</span><span class="w"></span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="linenos">30</span><span class="p">{</span><span class="w"></span>
<span class="linenos">31</span><span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">threads</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span><span class="w"></span>
<span class="linenos">32</span><span class="w">    </span><span class="n">thread_data_t</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span><span class="w"></span>
<span class="linenos">33</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="linenos">34</span><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="linenos">35</span><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="o">&lt;</span><span class="n">NUM_THREADS</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">36</span><span class="w">        </span><span class="n">thread_data</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="linenos">37</span><span class="w">        </span><span class="n">thread_data</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="linenos">38</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;In main: creating thread %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="linenos">39</span><span class="w">        </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">t</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">PrintHello</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_data</span><span class="p">[</span><span class="n">t</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">40</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">41</span><span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ERROR; return code from pthread_create() is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="p">);</span><span class="w"></span>
<span class="linenos">42</span><span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">43</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">44</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">    </span><span class="cm">/* Last thing that main() should do */</span><span class="w"></span>
<span class="linenos">47</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Exiting main thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">48</span><span class="w">    </span><span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">49</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This example is adapted from <a class="reference external" href="https://computing.llnl.gov/tutorials/pthreads">LLNL POSIX Threads Programming tutorial</a>. You can find these in our <code class="docutils literal notranslate"><span class="pre">systems-code-examples</span></code> repository in the <code class="docutils literal notranslate"><span class="pre">llnl_pthreads_examples</span></code> folder, which have been updated to compile cleanly and have proper build files.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="files-io.html" class="btn btn-neutral float-left" title="Files and I/O" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mutualexclusion.html" class="btn btn-neutral float-right" title="Mutual Exclusion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2020, Operating Systems Faculty at Loyola University Chicago.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>