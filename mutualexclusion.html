<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mutual Exclusion &mdash; Operating Systems Updated 2021-09-25 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deadlock" href="deadlock.html" />
    <link rel="prev" title="Process/Thread Scheduling" href="scheduling.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #922247" >
            <a href="index.html" class="icon icon-home"> Operating Systems
          </a>
              <div class="version">
                Updated 2021-09-25
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="meta.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Introduction to Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files-io.html">Files and I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Process/Thread Scheduling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mutual Exclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="deadlock.html">Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipc.html">IPC Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernelmm.html">Virtual Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="userlandmm.html">Userland Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">Storage and Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">Implementing Files and Folders</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Storage Research at Loyola</a></li>
<li class="toctree-l1"><a class="reference internal" href="linux_vm.html">Installing a Linux Virtual Machine with VMware</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows_vm.html">Installing a Windows Virtual Machine with VMware</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #922247" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Operating Systems</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Mutual Exclusion</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/mutualexclusion.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mutual-exclusion">
<h1>Mutual Exclusion<a class="headerlink" href="#mutual-exclusion" title="Permalink to this headline"></a></h1>
<section id="critical-sections">
<h2>Critical Sections<a class="headerlink" href="#critical-sections" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_t</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
        <span class="o">....</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>What will happen when more than one thread executes the increment method?</p></li>
<li><p>Which orders can the instructions be executed in?</p></li>
<li><p>What is the expected value of count?</p></li>
</ul>
</section>
<section id="identifying-the-critical-section">
<h2>Identifying the Critical Section<a class="headerlink" href="#identifying-the-critical-section" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>This is the critical section of the increment method</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The critical section is the section of code that only one thread may enter at one time for the program’s result to be definitely correct.</p></li>
<li><p>In some critical sections, it is possible for more than one thread to execute at the same time, but correctness is not guaranteed.</p></li>
</ul>
</section>
<section id="execution-orders-and-atomicity">
<h2>Execution Orders and Atomicity<a class="headerlink" href="#execution-orders-and-atomicity" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Code for the critical section</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Pseudo-assembly for the critical section</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
</pre></div>
</div>
<ul class="simple">
<li><dl class="simple">
<dt>Key points to remember:</dt><dd><ul>
<li><p>compilers aren’t always going to do what you expect</p></li>
<li><p>after the statement “count = x”, even up until several program statements later, you cannot be 100% guaranteed that the value has been stored to count</p></li>
<li><p>because of compiler optimizations, the value of count could be stored in a register for much longer than you expect. to deal with these scenarios, ‘volatile’ keywords will guarantee that stores are inserted earlier</p></li>
<li><p>don’t count on one program statement being translated into one atomic machine instruction. most are not. only single machine instructions can be atomic.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="id1">
<h2>Execution Orders and Atomicity<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>What are some possible execution orders for our pseudo-assembly?</p></li>
<li><p>With two threads on two different CPUs</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t0</span><span class="p">:</span> <span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t0</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
</pre></div>
</div>
<ul class="simple">
<li><p>In this case, instead of being 2, count would have a value of 1</p></li>
<li><p>Given the pseudo assembly program and two threads, how many permutations of the program would be equivalent to serial execution of one thread executing after the other in serial?</p></li>
<li><p>To achieve program correctness, we must eliminate all of the permutations that don’t have results equivalent to serial execution.</p></li>
<li><dl class="simple">
<dt>Solutions differ on:</dt><dd><ul>
<li><p>Whether execution re-tries are required</p></li>
<li><p>The amount of coordination / cooperation required</p></li>
<li><p>The underlying assumptions of the parallelism of the program (such as user vs. kernel threads).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="characteristics-of-a-good-locking-solution">
<h2>Characteristics of a Good Locking Solution<a class="headerlink" href="#characteristics-of-a-good-locking-solution" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>No two processes may be simultaneously inside their critical section</p></li>
<li><p>No assumptions may be made about speeds or the number of CPUs</p></li>
<li><p>No processes running outside of its critical section may block other processes</p></li>
<li><p>No process should have to wait forever to enter its critical section.</p></li>
</ul>
</section>
<section id="achieving-atomicity-serializability">
<h2>Achieving Atomicity / Serializability<a class="headerlink" href="#achieving-atomicity-serializability" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>There are two possible models to consider when writing programs: pessimistic locking and optimistic locking</p></li>
<li><dl class="simple">
<dt>Pessimistic locking:</dt><dd><ul>
<li><p>Locks on all resources needed for a critical section are obtained, the critical section is executed, then all locks are released</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Optimistic locking:</dt><dd><ul>
<li><p>A snapshot of the resource is made or a log of alterations is kept. The critical section is executed, then the snapshot or log are examined to see if the operation was atomic. If it was, then any alterations are committed, otherwise they are abandoned.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>For most frameworks and languages, pessimistic locking is the more used / accepted solution. With higher core counts and RAM sizes, optimistic locks are becoming more popular.</p></li>
</ul>
</section>
<section id="types-of-pessimistic-locks">
<h2>Types of Pessimistic Locks<a class="headerlink" href="#types-of-pessimistic-locks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Disabling Interrupts</p></li>
<li><p>Strict Alternation</p></li>
<li><p>Spin locks / mutexes</p></li>
<li><p>Semaphores</p></li>
<li><p>Condition variables / monitors</p></li>
<li><p>Reader / writer locks</p></li>
</ul>
</section>
<section id="types-of-optimistic-locks">
<h2>Types of Optimistic Locks<a class="headerlink" href="#types-of-optimistic-locks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Most non-database implementations make use of some kind of software transactional memory library</p></li>
</ul>
</section>
<section id="when-to-consider-optimistic-locking">
<h2>When to Consider Optimistic Locking<a class="headerlink" href="#when-to-consider-optimistic-locking" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>If your data structure is sparse.</dt><dd><ul>
<li><p>Example: you’re reading from and writing to a few values out of a 1-GB array.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The number of likely serial equivalent permutations of your code is high relative to the non serial.</p></li>
<li><dl class="simple">
<dt>The cost of communication is high relative to the cost of re-trying execution</dt><dd><ul>
<li><p>communication over networks</p></li>
<li><p>communication over NUMA systems with high CPU counts</p></li>
<li><p>when you have very high CPU counts</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="disabling-interrupts">
<h2>Disabling Interrupts<a class="headerlink" href="#disabling-interrupts" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>This is the simplest solution to making critical sections atomic.</p></li>
<li><p>Disabling interrupts prevents the scheduler from being invoked and therefore any code executed between disabling and enabling interrupts will be atomic.</p></li>
<li><dl class="simple">
<dt>Disabling interrupts is undesirable because:</dt><dd><ul>
<li><p>It is the least optimal solution in terms of resource utilization</p></li>
<li><p>Disabling interrupts is a privileged operation (only the operating system may do this)</p></li>
<li><p>If a program crashes while interrupts are disabled, interrupts will not be restored, the scheduler will not be invoked, and the entire computer will be essentially stopped.</p></li>
<li><p>In most architectures, disabling interrupts only happens on one CPU.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Disabling interrupts is useful in operating system kernels to achieve mutual exclusion</p></li>
</ul>
</section>
<section id="strict-alternation">
<h2>Strict Alternation<a class="headerlink" href="#strict-alternation" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>One or more processes take turns entering a critical section. This is controlled either by an external scheduler or by the use of a ‘turn’ variable.</p></li>
<li><p>In general this is a very bad solution: basically, one process can effectively lock the other by being slow in its non critical section of code.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">critical_section</span><span class="p">();</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">non_critical_section</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">critical_section</span><span class="p">();</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">non_critical_section</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="spin-locks">
<h2>Spin Locks<a class="headerlink" href="#spin-locks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Spin locks allow at most one owner of the lock. If a spin lock is agreed upon for a critical section of code, then locking a spin lock before entering and unlocking after exiting will make the critical section atomic.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>This critical section is now atomic.</p></li>
<li><p>What are the possible orders of execution now?</p></li>
</ul>
</section>
<section id="spin-locks-implementation">
<h2>Spin Locks - Implementation<a class="headerlink" href="#spin-locks-implementation" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Spin locks have two states: locked and not-locked.</p></li>
<li><p>The following is a pseudo algorithm for spin_lock and spin_unlock</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spin_lock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">spin_unlock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>while lock == 1, someone else holds it. once it switches to 0, it is unlocked, we set it to 1 and we’ve acquired the lock</p></li>
<li><p>the while loop is where the spin lock get’s its “spin” name</p></li>
<li><p>to unlock, we just set lock back to 0</p></li>
<li><p>what is the critical section in spin_lock()?</p></li>
<li><p>will the pseudo implementation work? why? or why not?</p></li>
</ul>
</section>
<section id="id2">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The pseudo implementation will not work. Its critical section is the entire method.</p></li>
<li><p>For example, if two threads are in spin_lock, when lock goes to 0, both threads may break out of the while loop and both set lock to 1. Then both threads would acquire the lock.</p></li>
<li><p>So, what we need to do, is to collapse the while loop into a single atomic operation.</p></li>
<li><p>This atomic operation will have to both test the value of lock and set it to 1 if it is ever zero</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spin_lock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id3">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>So, how do we implement test_and_set?</dt><dd><ul>
<li><p>There is no C/C++ keyword for this.</p></li>
<li><p>We have no guarantee that any C/C++ statement will be reduced to one atomic instruction.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>For this, we need to rely on a specialized machine instruction. On the x86, this is the xchg instruction.</p></li>
<li><p>x86 assembly version of spin_lock:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span><span class="p">:</span>
        <span class="n">dd</span>    <span class="mi">0</span>
<span class="n">spin_lock</span><span class="p">:</span>
        <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">loop</span><span class="p">:</span>
        <span class="n">xchg</span>  <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">lock</span><span class="p">]</span>
        <span class="n">test</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="n">jnz</span>   <span class="n">loop</span>
        <span class="n">ret</span>
</pre></div>
</div>
<ul class="simple">
<li><p>with the xchg instruction, our test and set operation is atomic</p></li>
</ul>
</section>
<section id="id4">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">test_and_set</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unsigned</span> <span class="n">long</span> <span class="n">newval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">asm</span> <span class="n">volatile</span><span class="p">(</span><span class="s2">&quot;lock: cmpxchgl %2, %0&quot;</span>
                <span class="p">:</span> <span class="s2">&quot;+m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">),</span> <span class="s2">&quot;+a&quot;</span> <span class="p">(</span><span class="n">newval</span><span class="p">)</span>
                <span class="p">:</span> <span class="s2">&quot;r&quot;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">:</span> <span class="s2">&quot;cc&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">newval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">spin_lock</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">test_and_setlock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">spin_unlock</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pthreads-mutex">
<h2>Pthreads - Mutex<a class="headerlink" href="#pthreads-mutex" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The pthreads library in Linux and Minix offer an efficient implementation of mutexes.</p></li>
<li><p>Rather than wasting CPU time by ‘spinning’, the thread is put to sleep if it cannot obtain the lock immediately.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
        <span class="n">pthread_mutex_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="mutexes-in-windows">
<h2>Mutexes in Windows<a class="headerlink" href="#mutexes-in-windows" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Windows also provides an efficient implementation for mutexes.</p></li>
<li><p>WaitForSingleObject locks mutexes (along with other lock primitives)</p></li>
<li><p>ReleaseMutex unlocks the mutex</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">HANDLE</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">CreateMutex</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">ReleaseMutex</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="semaphores-some-history">
<h2>Semaphores - some history<a class="headerlink" href="#semaphores-some-history" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The concept of a semaphore pre-dates the computing era.</p></li>
<li><p>The concept of semaphores was first introduced in the railroad industry. You can still see these used on the Chicago CTA or Metra</p></li>
<li><p>The most recent CTA derailment on the Green Line involved a semaphore</p></li>
<li><p>Many software locking techniques owe their inspiration from rail roads and industrial automation</p></li>
</ul>
</section>
<section id="semaphores">
<h2>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Semaphores support N-many threads entering a critical section at one time.</p></li>
<li><dl class="simple">
<dt>Semaphores are generalizations of spin locks</dt><dd><ul>
<li><p>Spin locks have two states: 0 - unlocked, 1 - locked</p></li>
<li><p>Semaphores have N states: 0 - locked, 1-N - unlocked</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Useful for protecting queue like data structures (more later)</p></li>
<li><p>Useful for protecting N-reader M-writer data structures (more later)</p></li>
<li><dl class="simple">
<dt>Semaphores have different operations than spin locks:</dt><dd><ul>
<li><p>Spin locks have lock, unlock</p></li>
<li><dl class="simple">
<dt>Semaphores have:</dt><dd><ul>
<li><p>up() - increases value of semaphore</p></li>
<li><p>down() - decreases value of semaphore - blocks while it is zero</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="semaphores-implementation">
<h2>Semaphores - Implementation<a class="headerlink" href="#semaphores-implementation" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Semaphores can be implemented on top of spin locksthat protect a count variable</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">up</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">semaphore</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">down</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">semaphore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">semaphore</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="binary-semaphores">
<h2>Binary semaphores<a class="headerlink" href="#binary-semaphores" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Emulate mutexes</p></li>
<li><p>Initial state is 1.</p></li>
<li><p>Possible states are 1: unlocked, 0: locked</p></li>
<li><p>Example:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="event-semaphores">
<h2>Event semaphores<a class="headerlink" href="#event-semaphores" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Used for signaling events.</p></li>
<li><p>Initial value is 0</p></li>
<li><p>Possible states are: 0 - unsignaled. 1 - signaled</p></li>
<li><p>Example:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">start</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
        <span class="n">event</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">done</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;total: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">event</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">done</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>producer starts consumer</p></li>
<li><p>producer sets up values</p></li>
<li><p>producer signals consumer and waits</p></li>
<li><p>consumer receives signal</p></li>
<li><p>consumer performs operation</p></li>
<li><p>consumer signals producer</p></li>
<li><p>producer wakes back up and prints result</p></li>
</ul>
</section>
<section id="id5">
<h2>Semaphores - Implementation<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>a good use case for semaphores is a producer / consumer problem:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>a class of problems exists here:</p></li>
<li><p>how does the consumer know an item is available in the queue?</p></li>
<li><p>how does the producer know that the queue isn’t full (5 items)?</p></li>
<li><p>how do we guarantee access to the queue is atomic - that queue and dequeue operations don’t interfere with each other?</p></li>
</ul>
</section>
<section id="id6">
<h2>Semaphores - Implementation<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Bounded buffer example</dt><dd><ul>
<li><p>mutex is a binary semaphore (states of 0 - locked, 1 - unlocked)</p></li>
<li><p>empty protects the condition of the queue being empty</p></li>
<li><p>full protects the condition of the queue being full</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">full</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="semaphores-reader-writer-locks">
<h2>Semaphores - reader / writer locks<a class="headerlink" href="#semaphores-reader-writer-locks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>In some cases, it is desirable to allow N-readers and M-writers on a shared resource.</p></li>
<li><p>The most typical case is N-readers and 1-writer. In this case, as many threads can read a value or 1 thread may write to the value at any time</p></li>
<li><p>Using reader-writer locks can allow for much higher concurrency than the use of binary semaphores or mutexes.</p></li>
<li><p>Reader / writer Lock Implementation</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">read</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">write</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">write</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span><span class="p">(</span><span class="n">readWait</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeRead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">read</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeRead</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id7">
<h2>Semaphores - reader/writer locks<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>As you can see from the previous slide, the implementation of a reader/writer lock can be complex.</p></li>
<li><p>Implementation details will vary depending on the conditions of the lock.</p></li>
<li><dl class="simple">
<dt>Some implementation considerations</dt><dd><ul>
<li><p>Who gets higher priority: readers or writers?</p></li>
<li><p>Do we allow users to downgrade or upgrade locks? i.e. can a read lock be translated to a write lock and can a write lock be translated to a read lock?</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>reader / writer locks can have some obscure and complex starvation / deadlock scenarios (more later)</p></li>
</ul>
</section>
<section id="semaphores-pthreads">
<h2>Semaphores - pthreads<a class="headerlink" href="#semaphores-pthreads" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sem_init(sem_t</span> <span class="pre">*sem,</span> <span class="pre">int</span> <span class="pre">pshared,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value)</span></code></p></li>
<li><p>sem is the semaphore</p></li>
<li><dl class="simple">
<dt>pshared - where the semaphore can be shard:</dt><dd><ul>
<li><p>0 - threads of a process - must be located in the heap</p></li>
<li><p>not 0 - between processes - must be located in shared memory</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>value - the initial value of a semaphore. Typical cases include:</dt><dd><ul>
<li><p>0 used for event semaphores</p></li>
<li><p>1 used for a binary semaphore</p></li>
<li><p>N used for a normal semaphore</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">sem_t</span> <span class="n">sema</span><span class="p">;</span>
        <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">);</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="windows-semaphores">
<h2>Windows - Semaphores<a class="headerlink" href="#windows-semaphores" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Windows also provides an efficient semaphore implementation.</p></li>
<li><p>Windows shares semaphores through names. The 4th paramenter in CreateSemaphore accepts a name. If you want to use an exising named semaphore, you call OpenSemaphore.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">const</span> <span class="nb">int</span> <span class="n">minCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">const</span> <span class="nb">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
        <span class="n">HANDLE</span> <span class="n">sema</span> <span class="o">=</span> <span class="n">CreateSemaphore</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">minCount</span><span class="p">,</span> <span class="n">maxCount</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">sema</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">sema</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="monitors-condition-variables">
<h2>Monitors / Condition Variables<a class="headerlink" href="#monitors-condition-variables" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Monitors are a higher level locking abstraction</p></li>
<li><dl class="simple">
<dt>Monitors have 4 operations:</dt><dd><ul>
<li><p>enter -lock the monitor</p></li>
<li><p>exit - unlock the monitor</p></li>
<li><p>wait - release the lock and put the thread to sleep. when wait() returns, automatically obtain the lock again</p></li>
<li><p>pulse - tell other threads to wake up and re-obtain the monitor lock</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Monitors permit much more complex locking conditions with simpler code than is possible with spin locks and semaphores in many cases</p></li>
</ul>
</section>
<section id="monitors">
<h2>Monitors<a class="headerlink" href="#monitors" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Monitor locks typically follow the following pattern:</dt><dd><ol class="arabic simple">
<li><p>enter()</p></li>
<li><p>while( condition to proceed is not true ) { wait(); }</p></li>
<li><p>do operation now that condition is true</p></li>
<li><p>if( condition has changed ) { pulse(); }</p></li>
<li><p>exit();</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>At the beginning of a critical section, enter() is called, at the end, exit() is called</p></li>
<li><p>After the call to enter() and just before the critical section, a while loop checks that it is okay to proceed while calling wait() on each iteration</p></li>
<li><p>After the while loop ends, we enter the critical section</p></li>
<li><p>If after the critical section, the condition for the critical section changes, call pulse()</p></li>
<li><p>after a possible call to pulse(), call exit() to end the lock and exit the critical section</p></li>
<li><p>The conditions in the while loop of the monitor lock can be very simple to very complex.</p></li>
<li><p>Even if the conditions become very complex, the operations on the monitor remain simple</p></li>
<li><p>The danger with complex conditions is that you need to make sure that all threads in their while loops will at some point break out of the while loop. Otherwise your -program will freeze up.</p></li>
<li><p>The performance for monitors is typically very good. spin locks and semaphores will outperform monitors in some cases</p></li>
</ul>
</section>
<section id="monitor-bounded-buffer">
<h2>Monitor - bounded buffer<a class="headerlink" href="#monitor-bounded-buffer" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Semaphore implementation:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">full</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id8">
<h2>Monitor - bounded buffer<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Enter</span><span class="p">();</span>
                <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Pulse</span><span class="p">();</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Exit</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Monitor</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Monitor</span><span class="p">();</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Enter</span><span class="p">();</span>
                <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Pulse</span><span class="p">();</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Exit</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>In this example, we call pulse() before every exit. We do this because the size of the queue is changed in the critical section and may allow the other thread to operate.</p></li>
</ul>
</section>
<section id="semaphore-reader-writer-lock">
<h2>Semaphore - reader/writer lock<a class="headerlink" href="#semaphore-reader-writer-lock" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
                <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">write</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span><span class="p">(</span><span class="n">readWait</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Semaphore</span> <span class="o">*</span><span class="n">read</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">write</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeRead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">read</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeRead</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="monitors-reader-writer-locks">
<h2>Monitors - Reader / Writer locks<a class="headerlink" href="#monitors-reader-writer-locks" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Monitor implementation is much simpler!</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Monitor</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Monitor</span><span class="p">();</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pthreads-condition-variables">
<h2>Pthreads - Condition Variables<a class="headerlink" href="#pthreads-condition-variables" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>pthreads uses condition variables to implement monitor like functions.</p></li>
<li><p>to use them, you will need a mutex and a condition variable:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
        <span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
        <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">/*</span> <span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">true</span> <span class="o">*/</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="windows-condition-variables">
<h2>Windows - Condition Variables<a class="headerlink" href="#windows-condition-variables" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Available in Windows Vista, 7, and Server 2008</p></li>
<li><p>Condition variables use CRITICAL_SECTION like pthread’s condition variables use a mutex. In this case the object is a spin lock and not a mutex.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">CONDITION_VARIABLE</span> <span class="n">cond</span><span class="p">;</span>
        <span class="n">CRITICAL_SECTION</span> <span class="n">lock</span><span class="p">;</span>

        <span class="n">InitializeConditionVariable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">/*</span><span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">true</span><span class="o">*/</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">SleepConditionVariableCS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">WakeConditionVariable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="scheduling.html" class="btn btn-neutral float-left" title="Process/Thread Scheduling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="deadlock.html" class="btn btn-neutral float-right" title="Deadlock" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2020, Operating Systems Faculty at Loyola University Chicago.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>