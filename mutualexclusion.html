

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mutual Exclusion &mdash; Operating Systems v0.9.2 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deadlock" href="deadlock.html" />
    <link rel="prev" title="Process/Thread Scheduling" href="scheduling.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Operating Systems
          

          
          </a>

          
            
            
              <div class="version">
                v0.9.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="meta.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Introduction to Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files-io.html">Files and I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Process/Thread Scheduling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mutual Exclusion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#critical-sections">Critical Sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#identifying-the-critical-section">Identifying the Critical Section</a></li>
<li class="toctree-l2"><a class="reference internal" href="#execution-orders-and-atomicity">Execution Orders and Atomicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Execution Orders and Atomicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#characteristics-of-a-good-locking-solution">Characteristics of a Good Locking Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#achieving-atomicity-serializability">Achieving Atomicity / Serializability</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-pessimistic-locks">Types of Pessimistic Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-optimistic-locks">Types of Optimistic Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#when-to-consider-optimistic-locking">When to Consider Optimistic Locking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disabling-interrupts">Disabling Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#strict-alternation">Strict Alternation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spin-locks">Spin Locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spin-locks-implementation">Spin Locks - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Spin Locks - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">Spin Locks - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Spin Locks - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pthreads-mutex">Pthreads - Mutex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mutexes-in-windows">Mutexes in Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphores-some-history">Semaphores - some history</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphores">Semaphores</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphores-implementation">Semaphores - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#binary-semaphores">Binary semaphores</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event-semaphores">Event semaphores</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">Semaphores - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Semaphores - Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphores-reader-writer-locks">Semaphores - reader / writer locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">Semaphores - reader/writer locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphores-pthreads">Semaphores - pthreads</a></li>
<li class="toctree-l2"><a class="reference internal" href="#windows-semaphores">Windows - Semaphores</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitors-condition-variables">Monitors / Condition Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitors">Monitors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitor-bounded-buffer">Monitor - bounded buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">Monitor - bounded buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semaphore-reader-writer-lock">Semaphore - reader/writer lock</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitors-reader-writer-locks">Monitors - Reader / Writer locks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pthreads-condition-variables">Pthreads - Condition Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#windows-condition-variables">Windows - Condition Variables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="deadlock.html">Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipc.html">IPC Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernelmm.html">Virtual Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="userlandmm.html">Userland Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">Storage and Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">Implementing Files and Folders</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Storage Research at Loyola</a></li>
<li class="toctree-l1"><a class="reference internal" href="linux_vm.html">Installing a Linux Virtual Machine with VMware</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows_vm.html">Installing a Windows Virtual Machine with VMware</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Operating Systems</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Mutual Exclusion</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mutualexclusion.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mutual-exclusion">
<h1>Mutual Exclusion<a class="headerlink" href="#mutual-exclusion" title="Permalink to this headline">¶</a></h1>
<div class="section" id="critical-sections">
<h2>Critical Sections<a class="headerlink" href="#critical-sections" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_t</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
        <span class="o">....</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>What will happen when more than one thread executes the increment method?</li>
<li>Which orders can the instructions be executed in?</li>
<li>What is the expected value of count?</li>
</ul>
</div>
<div class="section" id="identifying-the-critical-section">
<h2>Identifying the Critical Section<a class="headerlink" href="#identifying-the-critical-section" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>This is the critical section of the increment method</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>The critical section is the section of code that only one thread may enter at one time for the program’s result to be definitely correct.</li>
<li>In some critical sections, it is possible for more than one thread to execute at the same time, but correctness is not guaranteed.</li>
</ul>
</div>
<div class="section" id="execution-orders-and-atomicity">
<h2>Execution Orders and Atomicity<a class="headerlink" href="#execution-orders-and-atomicity" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Code for the critical section</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>Pseudo-assembly for the critical section</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
</pre></div>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>Key points to remember:</dt>
<dd><ul class="first last">
<li>compilers aren’t always going to do what you expect</li>
<li>after the statement “count = x”, even up until several program statements later, you cannot be 100% guaranteed that the value has been stored to count</li>
<li>because of compiler optimizations, the value of count could be stored in a register for much longer than you expect. to deal with these scenarios, ‘volatile’ keywords will guarantee that stores are inserted earlier</li>
<li>don’t count on one program statement being translated into one atomic machine instruction. most are not. only single machine instructions can be atomic.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2>Execution Orders and Atomicity<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>What are some possible execution orders for our pseudo-assembly?</li>
<li>With two threads on two different CPUs</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t0</span><span class="p">:</span> <span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">load</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t0</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t0</span><span class="p">:</span> <span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">add</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r1</span>
<span class="n">t1</span><span class="p">:</span> <span class="nb">set</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
<span class="n">t1</span><span class="p">:</span> <span class="n">store</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">r0</span>
</pre></div>
</div>
<ul class="simple">
<li>In this case, instead of being 2, count would have a value of 1</li>
<li>Given the pseudo assembly program and two threads, how many permutations of the program would be equivalent to serial execution of one thread executing after the other in serial?</li>
<li>To achieve program correctness, we must eliminate all of the permutations that don’t have results equivalent to serial execution.</li>
<li><dl class="first docutils">
<dt>Solutions differ on:</dt>
<dd><ul class="first last">
<li>Whether execution re-tries are required</li>
<li>The amount of coordination / cooperation required</li>
<li>The underlying assumptions of the parallelism of the program (such as user vs. kernel threads).</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="characteristics-of-a-good-locking-solution">
<h2>Characteristics of a Good Locking Solution<a class="headerlink" href="#characteristics-of-a-good-locking-solution" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>No two processes may be simultaneously inside their critical section</li>
<li>No assumptions may be made about speeds or the number of CPUs</li>
<li>No processes running outside of its critical section may block other processes</li>
<li>No process should have to wait forever to enter its critical section.</li>
</ul>
</div>
<div class="section" id="achieving-atomicity-serializability">
<h2>Achieving Atomicity / Serializability<a class="headerlink" href="#achieving-atomicity-serializability" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>There are two possible models to consider when writing programs: pessimistic locking and optimistic locking</li>
<li><dl class="first docutils">
<dt>Pessimistic locking:</dt>
<dd><ul class="first last">
<li>Locks on all resources needed for a critical section are obtained, the critical section is executed, then all locks are released</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Optimistic locking:</dt>
<dd><ul class="first last">
<li>A snapshot of the resource is made or a log of alterations is kept. The critical section is executed, then the snapshot or log are examined to see if the operation was atomic. If it was, then any alterations are committed, otherwise they are abandoned.</li>
</ul>
</dd>
</dl>
</li>
<li>For most frameworks and languages, pessimistic locking is the more used / accepted solution. With higher core counts and RAM sizes, optimistic locks are becoming more popular.</li>
</ul>
</div>
<div class="section" id="types-of-pessimistic-locks">
<h2>Types of Pessimistic Locks<a class="headerlink" href="#types-of-pessimistic-locks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Disabling Interrupts</li>
<li>Strict Alternation</li>
<li>Spin locks / mutexes</li>
<li>Semaphores</li>
<li>Condition variables / monitors</li>
<li>Reader / writer locks</li>
</ul>
</div>
<div class="section" id="types-of-optimistic-locks">
<h2>Types of Optimistic Locks<a class="headerlink" href="#types-of-optimistic-locks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Most non-database implementations make use of some kind of software transactional memory library</li>
</ul>
</div>
<div class="section" id="when-to-consider-optimistic-locking">
<h2>When to Consider Optimistic Locking<a class="headerlink" href="#when-to-consider-optimistic-locking" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt>If your data structure is sparse.</dt>
<dd><ul class="first last">
<li>Example: you’re reading from and writing to a few values out of a 1-GB array.</li>
</ul>
</dd>
</dl>
</li>
<li>The number of likely serial equivalent permutations of your code is high relative to the non serial.</li>
<li><dl class="first docutils">
<dt>The cost of communication is high relative to the cost of re-trying execution</dt>
<dd><ul class="first last">
<li>communication over networks</li>
<li>communication over NUMA systems with high CPU counts</li>
<li>when you have very high CPU counts</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="disabling-interrupts">
<h2>Disabling Interrupts<a class="headerlink" href="#disabling-interrupts" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>This is the simplest solution to making critical sections atomic.</li>
<li>Disabling interrupts prevents the scheduler from being invoked and therefore any code executed between disabling and enabling interrupts will be atomic.</li>
<li><dl class="first docutils">
<dt>Disabling interrupts is undesirable because:</dt>
<dd><ul class="first last">
<li>It is the least optimal solution in terms of resource utilization</li>
<li>Disabling interrupts is a privileged operation (only the operating system may do this)</li>
<li>If a program crashes while interrupts are disabled, interrupts will not be restored, the scheduler will not be invoked, and the entire computer will be essentially stopped.</li>
<li>In most architectures, disabling interrupts only happens on one CPU.</li>
</ul>
</dd>
</dl>
</li>
<li>Disabling interrupts is useful in operating system kernels to achieve mutual exclusion</li>
</ul>
</div>
<div class="section" id="strict-alternation">
<h2>Strict Alternation<a class="headerlink" href="#strict-alternation" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>One or more processes take turns entering a critical section. This is controlled either by an external scheduler or by the use of a ‘turn’ variable.</li>
<li>In general this is a very bad solution: basically, one process can effectively lock the other by being slow in its non critical section of code.</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">critical_section</span><span class="p">();</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">non_critical_section</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">critical_section</span><span class="p">();</span>
        <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">non_critical_section</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="spin-locks">
<h2>Spin Locks<a class="headerlink" href="#spin-locks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Spin locks allow at most one owner of the lock. If a spin lock is agreed upon for a critical section of code, then locking a spin lock before entering and unlocking after exiting will make the critical section atomic.</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>This critical section is now atomic.</li>
<li>What are the possible orders of execution now?</li>
</ul>
</div>
<div class="section" id="spin-locks-implementation">
<h2>Spin Locks - Implementation<a class="headerlink" href="#spin-locks-implementation" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Spin locks have two states: locked and not-locked.</li>
<li>The following is a pseudo algorithm for spin_lock and spin_unlock</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spin_lock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">spin_unlock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>while lock == 1, someone else holds it. once it switches to 0, it is unlocked, we set it to 1 and we’ve acquired the lock</li>
<li>the while loop is where the spin lock get’s its “spin” name</li>
<li>to unlock, we just set lock back to 0</li>
<li>what is the critical section in spin_lock()?</li>
<li>will the pseudo implementation work? why? or why not?</li>
</ul>
</div>
<div class="section" id="id2">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The pseudo implementation will not work. Its critical section is the entire method.</li>
<li>For example, if two threads are in spin_lock, when lock goes to 0, both threads may break out of the while loop and both set lock to 1. Then both threads would acquire the lock.</li>
<li>So, what we need to do, is to collapse the while loop into a single atomic operation.</li>
<li>This atomic operation will have to both test the value of lock and set it to 1 if it is ever zero</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spin_lock</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt>So, how do we implement test_and_set?</dt>
<dd><ul class="first last">
<li>There is no C/C++ keyword for this.</li>
<li>We have no guarantee that any C/C++ statement will be reduced to one atomic instruction.</li>
</ul>
</dd>
</dl>
</li>
<li>For this, we need to rely on a specialized machine instruction. On the x86, this is the xchg instruction.</li>
<li>x86 assembly version of spin_lock:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span><span class="p">:</span>
        <span class="n">dd</span>    <span class="mi">0</span>
<span class="n">spin_lock</span><span class="p">:</span>
        <span class="n">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">loop</span><span class="p">:</span>
        <span class="n">xchg</span>  <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">lock</span><span class="p">]</span>
        <span class="n">test</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="n">jnz</span>   <span class="n">loop</span>
        <span class="n">ret</span>
</pre></div>
</div>
<ul class="simple">
<li>with the xchg instruction, our test and set operation is atomic</li>
</ul>
</div>
<div class="section" id="id4">
<h2>Spin Locks - Implementation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">test_and_set</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="o">*</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unsigned</span> <span class="n">long</span> <span class="n">newval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">asm</span> <span class="n">volatile</span><span class="p">(</span><span class="s2">&quot;lock: cmpxchgl %2, %0&quot;</span>
                <span class="p">:</span> <span class="s2">&quot;+m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">),</span> <span class="s2">&quot;+a&quot;</span> <span class="p">(</span><span class="n">newval</span><span class="p">)</span>
                <span class="p">:</span> <span class="s2">&quot;r&quot;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">:</span> <span class="s2">&quot;cc&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">newval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">spin_lock</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">test_and_setlock</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">spin_unlock</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pthreads-mutex">
<h2>Pthreads - Mutex<a class="headerlink" href="#pthreads-mutex" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The pthreads library in Linux and Minix offer an efficient implementation of mutexes.</li>
<li>Rather than wasting CPU time by ‘spinning’, the thread is put to sleep if it cannot obtain the lock immediately.</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
        <span class="n">pthread_mutex_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mutexes-in-windows">
<h2>Mutexes in Windows<a class="headerlink" href="#mutexes-in-windows" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Windows also provides an efficient implementation for mutexes.</li>
<li>WaitForSingleObject locks mutexes (along with other lock primitives)</li>
<li>ReleaseMutex unlocks the mutex</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">HANDLE</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">CreateMutex</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">ReleaseMutex</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="semaphores-some-history">
<h2>Semaphores - some history<a class="headerlink" href="#semaphores-some-history" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The concept of a semaphore pre-dates the computing era.</li>
<li>The concept of semaphores was first introduced in the railroad industry. You can still see these used on the Chicago CTA or Metra</li>
<li>The most recent CTA derailment on the Green Line involved a semaphore</li>
<li>Many software locking techniques owe their inspiration from rail roads and industrial automation</li>
</ul>
</div>
<div class="section" id="semaphores">
<h2>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Semaphores support N-many threads entering a critical section at one time.</li>
<li><dl class="first docutils">
<dt>Semaphores are generalizations of spin locks</dt>
<dd><ul class="first last">
<li>Spin locks have two states: 0 - unlocked, 1 - locked</li>
<li>Semaphores have N states: 0 - locked, 1-N - unlocked</li>
</ul>
</dd>
</dl>
</li>
<li>Useful for protecting queue like data structures (more later)</li>
<li>Useful for protecting N-reader M-writer data structures (more later)</li>
<li><dl class="first docutils">
<dt>Semaphores have different operations than spin locks:</dt>
<dd><ul class="first last">
<li>Spin locks have lock, unlock</li>
<li><dl class="first docutils">
<dt>Semaphores have:</dt>
<dd><ul class="first last">
<li>up() - increases value of semaphore</li>
<li>down() - decreases value of semaphore - blocks while it is zero</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="semaphores-implementation">
<h2>Semaphores - Implementation<a class="headerlink" href="#semaphores-implementation" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Semaphores can be implemented on top of spin locksthat protect a count variable</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">up</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">semaphore</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">down</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">semaphore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">semaphore</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-semaphores">
<h2>Binary semaphores<a class="headerlink" href="#binary-semaphores" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Emulate mutexes</li>
<li>Initial state is 1.</li>
<li>Possible states are 1: unlocked, 0: locked</li>
<li>Example:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">increment</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="event-semaphores">
<h2>Event semaphores<a class="headerlink" href="#event-semaphores" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Used for signaling events.</li>
<li>Initial value is 0</li>
<li>Possible states are: 0 - unsignaled. 1 - signaled</li>
<li>Example:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">start</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
        <span class="n">event</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">done</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;total: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">event</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">done</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>producer starts consumer</li>
<li>producer sets up values</li>
<li>producer signals consumer and waits</li>
<li>consumer receives signal</li>
<li>consumer performs operation</li>
<li>consumer signals producer</li>
<li>producer wakes back up and prints result</li>
</ul>
</div>
<div class="section" id="id5">
<h2>Semaphores - Implementation<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>a good use case for semaphores is a producer / consumer problem:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>a class of problems exists here:</li>
<li>how does the consumer know an item is available in the queue?</li>
<li>how does the producer know that the queue isn’t full (5 items)?</li>
<li>how do we guarantee access to the queue is atomic - that queue and dequeue operations don’t interfere with each other?</li>
</ul>
</div>
<div class="section" id="id6">
<h2>Semaphores - Implementation<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt>Bounded buffer example</dt>
<dd><ul class="first last">
<li>mutex is a binary semaphore (states of 0 - locked, 1 - unlocked)</li>
<li>empty protects the condition of the queue being empty</li>
<li>full protects the condition of the queue being full</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">full</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="semaphores-reader-writer-locks">
<h2>Semaphores - reader / writer locks<a class="headerlink" href="#semaphores-reader-writer-locks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>In some cases, it is desirable to allow N-readers and M-writers on a shared resource.</li>
<li>The most typical case is N-readers and 1-writer. In this case, as many threads can read a value or 1 thread may write to the value at any time</li>
<li>Using reader-writer locks can allow for much higher concurrency than the use of binary semaphores or mutexes.</li>
<li>Reader / writer Lock Implementation</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Semaphore</span> <span class="o">*</span><span class="n">read</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">write</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">write</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span><span class="p">(</span><span class="n">readWait</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeRead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">read</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeRead</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>Semaphores - reader/writer locks<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>As you can see from the previous slide, the implementation of a reader/writer lock can be complex.</li>
<li>Implementation details will vary depending on the conditions of the lock.</li>
<li><dl class="first docutils">
<dt>Some implementation considerations</dt>
<dd><ul class="first last">
<li>Who gets higher priority: readers or writers?</li>
<li>Do we allow users to downgrade or upgrade locks? i.e. can a read lock be translated to a write lock and can a write lock be translated to a read lock?</li>
</ul>
</dd>
</dl>
</li>
<li>reader / writer locks can have some obscure and complex starvation / deadlock scenarios (more later)</li>
</ul>
</div>
<div class="section" id="semaphores-pthreads">
<h2>Semaphores - pthreads<a class="headerlink" href="#semaphores-pthreads" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sem_init(sem_t</span> <span class="pre">*sem,</span> <span class="pre">int</span> <span class="pre">pshared,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value)</span></code></li>
<li>sem is the semaphore</li>
<li><dl class="first docutils">
<dt>pshared - where the semaphore can be shard:</dt>
<dd><ul class="first last">
<li>0 - threads of a process - must be located in the heap</li>
<li>not 0 - between processes - must be located in shared memory</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>value - the initial value of a semaphore. Typical cases include:</dt>
<dd><ul class="first last">
<li>0 used for event semaphores</li>
<li>1 used for a binary semaphore</li>
<li>N used for a normal semaphore</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">sem_t</span> <span class="n">sema</span><span class="p">;</span>
        <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">);</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sema</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="windows-semaphores">
<h2>Windows - Semaphores<a class="headerlink" href="#windows-semaphores" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Windows also provides an efficient semaphore implementation.</li>
<li>Windows shares semaphores through names. The 4th paramenter in CreateSemaphore accepts a name. If you want to use an exising named semaphore, you call OpenSemaphore.</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">const</span> <span class="nb">int</span> <span class="n">minCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">const</span> <span class="nb">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
        <span class="n">HANDLE</span> <span class="n">sema</span> <span class="o">=</span> <span class="n">CreateSemaphore</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">minCount</span><span class="p">,</span> <span class="n">maxCount</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>

        <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">sema</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>

        <span class="n">ReleaseSemaphore</span><span class="p">(</span><span class="n">sema</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="monitors-condition-variables">
<h2>Monitors / Condition Variables<a class="headerlink" href="#monitors-condition-variables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Monitors are a higher level locking abstraction</li>
<li><dl class="first docutils">
<dt>Monitors have 4 operations:</dt>
<dd><ul class="first last">
<li>enter -lock the monitor</li>
<li>exit - unlock the monitor</li>
<li>wait - release the lock and put the thread to sleep. when wait() returns, automatically obtain the lock again</li>
<li>pulse - tell other threads to wake up and re-obtain the monitor lock</li>
</ul>
</dd>
</dl>
</li>
<li>Monitors permit much more complex locking conditions with simpler code than is possible with spin locks and semaphores in many cases</li>
</ul>
</div>
<div class="section" id="monitors">
<h2>Monitors<a class="headerlink" href="#monitors" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt>Monitor locks typically follow the following pattern:</dt>
<dd><ol class="first last arabic">
<li>enter()</li>
<li>while( condition to proceed is not true ) { wait(); }</li>
<li>do operation now that condition is true</li>
<li>if( condition has changed ) { pulse(); }</li>
<li>exit();</li>
</ol>
</dd>
</dl>
</li>
<li>At the beginning of a critical section, enter() is called, at the end, exit() is called</li>
<li>After the call to enter() and just before the critical section, a while loop checks that it is okay to proceed while calling wait() on each iteration</li>
<li>After the while loop ends, we enter the critical section</li>
<li>If after the critical section, the condition for the critical section changes, call pulse()</li>
<li>after a possible call to pulse(), call exit() to end the lock and exit the critical section</li>
<li>The conditions in the while loop of the monitor lock can be very simple to very complex.</li>
<li>Even if the conditions become very complex, the operations on the monitor remain simple</li>
<li>The danger with complex conditions is that you need to make sure that all threads in their while loops will at some point break out of the while loop. Otherwise your -program will freeze up.</li>
<li>The performance for monitors is typically very good. spin locks and semaphores will outperform monitors in some cases</li>
</ul>
</div>
<div class="section" id="monitor-bounded-buffer">
<h2>Monitor - bounded buffer<a class="headerlink" href="#monitor-bounded-buffer" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Semaphore implementation:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">full</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">full</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">mutex</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">empty</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>Monitor - bounded buffer<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Enter</span><span class="p">();</span>
                <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Dequeue</span><span class="p">();</span>
                <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Pulse</span><span class="p">();</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Exit</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">Monitor</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Monitor</span><span class="p">();</span>

<span class="n">void</span> <span class="n">producer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Enter</span><span class="p">();</span>
                <span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="nb">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
                <span class="n">queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Pulse</span><span class="p">();</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">Exit</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>In this example, we call pulse() before every exit. We do this because the size of the queue is changed in the critical section and may allow the other thread to operate.</li>
</ul>
</div>
<div class="section" id="semaphore-reader-writer-lock">
<h2>Semaphore - reader/writer lock<a class="headerlink" href="#semaphore-reader-writer-lock" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
                <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">write</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span><span class="p">(</span><span class="n">readWait</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Semaphore</span> <span class="o">*</span><span class="n">read</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">write</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Semaphore</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">read</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeRead</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
        <span class="n">read</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">activeRead</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">write</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
                <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">writeWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="monitors-reader-writer-locks">
<h2>Monitors - Reader / Writer locks<a class="headerlink" href="#monitors-reader-writer-locks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Monitor implementation is much simpler!</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Monitor</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Monitor</span><span class="p">();</span>
<span class="nb">int</span> <span class="n">readWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">writeWait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">activeRead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activeWrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">BeginRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">readWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">writeWait</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">readWait</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">activeRead</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndRead</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">activeRead</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">StartWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">writeWait</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">activeWrite</span><span class="o">+</span><span class="n">activeRead</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">activeWrite</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">EndWrite</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">enter</span><span class="p">();</span>
        <span class="n">activeWrite</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">pulse</span><span class="p">();</span>
        <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pthreads-condition-variables">
<h2>Pthreads - Condition Variables<a class="headerlink" href="#pthreads-condition-variables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>pthreads uses condition variables to implement monitor like functions.</li>
<li>to use them, you will need a mutex and a condition variable:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
        <span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
        <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">/*</span> <span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">true</span> <span class="o">*/</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="windows-condition-variables">
<h2>Windows - Condition Variables<a class="headerlink" href="#windows-condition-variables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Available in Windows Vista, 7, and Server 2008</li>
<li>Condition variables use CRITICAL_SECTION like pthread’s condition variables use a mutex. In this case the object is a spin lock and not a mutex.</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">CONDITION_VARIABLE</span> <span class="n">cond</span><span class="p">;</span>
        <span class="n">CRITICAL_SECTION</span> <span class="n">lock</span><span class="p">;</span>

        <span class="n">InitializeConditionVariable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">/*</span><span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">true</span><span class="o">*/</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">SleepConditionVariableCS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">//</span><span class="n">critical</span> <span class="n">section</span>
        <span class="n">WakeConditionVariable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="deadlock.html" class="btn btn-neutral float-right" title="Deadlock" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="scheduling.html" class="btn btn-neutral float-left" title="Process/Thread Scheduling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2013-2020, Operating Systems Faculty at Loyola University Chicago

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>