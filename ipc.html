<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IPC Topics &mdash; Operating Systems Updated 2021-09-25 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Virtual Memory" href="kernelmm.html" />
    <link rel="prev" title="Deadlock" href="deadlock.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Operating Systems
          </a>
              <div class="version">
                Updated 2021-09-25
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="meta.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Introduction to Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files-io.html">Files and I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Process/Thread Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutualexclusion.html">Mutual Exclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="deadlock.html">Deadlock</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">IPC Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ipc-performance-hierarchy">IPC Performance Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pipes">Pipes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Pipes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pipes-linux">Pipes - Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pipes-context-switches">Pipes - Context Switches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#named-pipes-fifos">Named Pipes / FIFOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-usage-of-a-regular-pipe-in-linux">Example usage of a regular pipe in Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="#named-pipes-common-usages">Named Pipes - Common Usages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#named-pipes-atomic-reads-writes">Named Pipes - Atomic Reads / Writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signals">Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#list-of-important-signals">List of Important Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#handling-signals-example">Handling Signals - Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sending-signals-example">Sending Signals - Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signals-interrupted-system-calls">Signals - Interrupted System Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signals-reentrant-functions">Signals - Reentrant Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Signals - Reentrant Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#signals-sending-in-code">Signals - Sending In Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-implementing-sleep-with-alarm">Example - implementing sleep() with alarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-better-sleep-implementation">Example - “better” sleep implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#demonstrating-the-sleepfor-problem">Demonstrating the sleepFor problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="#history-of-sleep-and-why-signals-are-scary">History of sleep and why signals are scary.</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-uses-for-alarm">Other uses for alarm(…)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-files">Memory Mapped Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">Memory Mapped Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Memory Mapped Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-files-virtual-addresses">Memory Mapped Files - Virtual Addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#absolute-memory-addressing">Absolute Memory Addressing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#relative-memory-addressing">Relative Memory Addressing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linux-minix-use-of-mmap">Linux / Minix - Use of mmap()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mmap-simple-example">mmap - simple example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">mmap - simple example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-files-atomicity">Memory Mapped Files - Atomicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-files-bounded-buffer">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">Memory Mapped Files - Bounded Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-mapped-files-fast-i-o">Memory Mapped Files - Fast I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">Memory Mapped Files - Fast I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="#files-ipc">Files - IPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#files-exposing-current-state">Files - Exposing Current State</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spool-folders">Spool Folders</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spool-folders-cron">Spool Folders - Cron</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spool-folders-cups">Spool Folders - CUPS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lock-files">Lock Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#doors">Doors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#server-code">Server Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#client-code">Client Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#domain-sockets">Domain Sockets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#domain-sockets-example">Domain Sockets - Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">Domain Sockets - Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">Domain Sockets - Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="kernelmm.html">Virtual Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="userlandmm.html">Userland Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">Storage and Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">Implementing Files and Folders</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Storage Research at Loyola</a></li>
<li class="toctree-l1"><a class="reference internal" href="linux_vm.html">Installing a Linux Virtual Machine with VMware</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows_vm.html">Installing a Windows Virtual Machine with VMware</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Operating Systems</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>IPC Topics</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ipc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ipc-topics">
<h1>IPC Topics<a class="headerlink" href="#ipc-topics" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p>Pipes</p></li>
<li><p>Named Pipes / FIFOs</p></li>
<li><p>Signals</p></li>
<li><p>Shared memory</p></li>
<li><p>Memory mapped files</p></li>
<li><p>Locking in shared memory</p></li>
<li><p>Files</p></li>
<li><p>Domain sockets</p></li>
<li><p>Doors</p></li>
<li><p>TCP/IP</p></li>
</ul>
<section id="ipc-performance-hierarchy">
<h2>IPC Performance Hierarchy<a class="headerlink" href="#ipc-performance-hierarchy" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Fastest - no kernel interaction needed, except to setup:</dt><dd><ul>
<li><p>Shared memory</p></li>
<li><p>Locking in shared memory</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Very fast - virtual memory manager involved</dt><dd><ul>
<li><p>Memory mapped files</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Fast - system calls required - i.e. context switches</dt><dd><ul>
<li><p>Pipes, FIFOs / Named Pipes</p></li>
<li><p>Signals</p></li>
<li><p>Domain sockets</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Medium / Slow - FS or network involved</dt><dd><ul>
<li><p>Files</p></li>
<li><p>TCP/UDP sockets</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="pipes">
<h2>Pipes<a class="headerlink" href="#pipes" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Pipes are the oldest UNIX IPC mechanism aside from files.</p></li>
<li><p>Pipes are half-duplex - data only flows in one direction</p></li>
<li><p>Pipes can only be used between processes that have a common
parent. Pipes are created by a parent process and then inherited across a fork() call.</p></li>
<li><p>Passing data from one process to another through a pipe involves at least two context switches. A third one is necessary for control to return to the writing process.</p></li>
<li><p>Pipes in general are very fast. Sending data at rates of 100s to 1000s of MB/s is possible.</p></li>
</ul>
</section>
<section id="id1">
<h2>Pipes<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Pipes have two file descriptors</dt><dd><ul>
<li><p>One file descriptor is read-only</p></li>
<li><p>One file descriptor is write-only</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The Linux call to create a pipe is:</dt><dd><ul>
<li><p>int pipe(int pipefd[2]);</p></li>
<li><p>pipefd[0] is the read-only half</p></li>
<li><p>pipefd[1] is the write-only half</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The Windows call to create a pipe is:</dt><dd><ul>
<li><p>BOOL CreatePipe(HANDLE readHandle, HANDLE writeHandle, LPSECURITY_ATTRIBUTES attr, DWORD nSize);</p></li>
<li><p>readHandle and writeHandle are the read/write file handles</p></li>
<li><p>attr allows processes that run under more than one user account to manage security of individual pipes</p></li>
<li><p>nSize is the suggested buffer size for the pipe</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="pipes-linux">
<h2>Pipes - Linux<a class="headerlink" href="#pipes-linux" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="linenos"> 3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="linenos"> 4</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pipes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">        </span><span class="n">pipe</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">inputPartOfPipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="linenos">12</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">outputPartOfPipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//parent process</span>
<span class="linenos">17</span><span class="w">                </span><span class="n">dup2</span><span class="p">(</span><span class="n">inputPartOfPipe</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// redirect STDIN</span>
<span class="linenos">18</span><span class="w">                </span><span class="n">close</span><span class="p">(</span><span class="n">outputPartOfPipe</span><span class="p">);</span><span class="w">  </span><span class="c1">// close unused half of pipe</span>
<span class="linenos">19</span><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="w">                </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;child sent value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//child process</span>
<span class="linenos">23</span><span class="w">                </span><span class="n">dup2</span><span class="p">(</span><span class="n">outputPartOfPipe</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// redirect STDOUT</span>
<span class="linenos">24</span><span class="w">                </span><span class="n">close</span><span class="p">(</span><span class="n">inputPartOfPipe</span><span class="p">);</span><span class="w">     </span><span class="c1">// close unused half of pipe</span>
<span class="linenos">25</span><span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5000</span><span class="p">);</span><span class="w"></span>
<span class="linenos">26</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">27</span><span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;fork failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">29</span>
<span class="linenos">30</span><span class="w">        </span><span class="c1">//don&#39;t worry about closing remaining pipes,</span>
<span class="linenos">31</span><span class="w">        </span><span class="c1">//process exit does this for us</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">34</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="pipes-context-switches">
<h2>Pipes - Context Switches<a class="headerlink" href="#pipes-context-switches" title="Permalink to this headline"></a></h2>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/pipes-context-switches.png"><img alt="Pipes and Context Switching" src="_images/pipes-context-switches.png" style="width: 600px;" /></a>
</figure>
</section>
<section id="named-pipes-fifos">
<h2>Named Pipes / FIFOs<a class="headerlink" href="#named-pipes-fifos" title="Permalink to this headline"></a></h2>
<p>Named pipes are the same as regular pipes except:</p>
<ul class="simple">
<li><p>Named pipes live in the filesystem namespace</p></li>
<li><p>Named pipes can have a different lifespan than individual processes</p></li>
<li><p>Since named pipes are files, you can apply more advanced permissions to them</p></li>
</ul>
</section>
<section id="example-usage-of-a-regular-pipe-in-linux">
<h2>Example usage of a regular pipe in Linux<a class="headerlink" href="#example-usage-of-a-regular-pipe-in-linux" title="Permalink to this headline"></a></h2>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat file | gzip -c9 &gt; file.gz
</pre></div>
</div>
<p>Example usage of a named pipe in Linux:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mkfifo pipe_file
$ gzip -c9 &lt; pipe_file &gt; file.gz
$ cat file &gt; pipe_file
$ rm -f pipe_file
</pre></div>
</div>
</section>
<section id="named-pipes-common-usages">
<h2>Named Pipes - Common Usages<a class="headerlink" href="#named-pipes-common-usages" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Named pipes are commonly used for single machine client / server applications</p></li>
<li><p>In Windows, named pipes can ride on top of TCP/IP and be used for intra-machine IPC.</p></li>
<li><dl class="simple">
<dt>To improve performance of applications that are written to only work with files and not with normal pipes.</dt><dd><ul>
<li><p>Does not work if the program uses random I/O</p></li>
<li><p>A program that is written to read a large file from disk can instead read from a named pipe. The named pipe’s data can in turn be produced by another program.</p></li>
<li><p>A program that can only work with files from the local disk can be made to work with a file on the web through a named pipe and a command that can write a URL to standard output</p></li>
<li><p>This pattern can be used to add encryption, file compression, and other extensions to programs that do not already have them.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="named-pipes-atomic-reads-writes">
<h2>Named Pipes - Atomic Reads / Writes<a class="headerlink" href="#named-pipes-atomic-reads-writes" title="Permalink to this headline"></a></h2>
<p>What happens if two processes write to a named pipe at the same time?</p>
<ul class="simple">
<li><p>If the size of each write(…) call is &lt;= PIPE_BUF, the writes will be atomic and in order.</p></li>
<li><p>If the size of each write(…) call is &gt; PIPE_BUF, then the individual writes will be broken up and interleaved with other simultaneous callers.</p></li>
<li><p>So, a good rule of thumb, is to make sure that what you write to a named pipe is less than PIPE_BUF in size. Otherwise, you need to guarantee that you are the only one writing to the pipe file</p></li>
</ul>
</section>
<section id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Signals are software interrupts / events</p></li>
<li><p>Provide a way for handling asynchronous events</p></li>
<li><p>Modern UNIX systems have &gt; 30 different signals defined</p></li>
<li><dl class="simple">
<dt>Signals have a concept of disposition or action</dt><dd><ul>
<li><p>Ignore the signal: works for all signals except SIGKILL, SIGSTOP, and SIGEMT</p></li>
<li><p>Catch the signal: program registers with the kernel a function to handle a signal.</p></li>
<li><p>Default: allows the signal to perform its default action. Every signal has a default action</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="list-of-important-signals">
<h2>List of Important Signals<a class="headerlink" href="#list-of-important-signals" title="Permalink to this headline"></a></h2>
<table class="colwidths-given docutils align-default" id="id15">
<caption><span class="caption-text">List of Important Signals</span><a class="headerlink" href="#id15" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Signal</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SIGABRT</p></td>
<td><p>abnormal termination, generated by abort() function. Default terminates and core dumps the process.</p></td>
</tr>
<tr class="row-odd"><td><p>SIGALRM</p></td>
<td><p>generated when a timer expires. Set by alarm() function.</p></td>
</tr>
<tr class="row-even"><td><p>SIGBUS</p></td>
<td><p>Indicates a hardware fault. Often memory protection faults. Default terminates the application.</p></td>
</tr>
<tr class="row-odd"><td><p>SIGCHLD</p></td>
<td><p>Sent to a parent process when a child process terminates.</p></td>
</tr>
<tr class="row-even"><td><p>SIGCONT</p></td>
<td><p>Sent to a stopped process when it is continued.</p></td>
</tr>
<tr class="row-odd"><td><p>SIGEMT</p></td>
<td><p>General hardware fault</p></td>
</tr>
<tr class="row-even"><td><p>SIGFPE</p></td>
<td><p>Arithmetic exception: divide by 0, floating point overflow, etc…</p></td>
</tr>
<tr class="row-odd"><td><p>SIGHUP</p></td>
<td><p>Terminal is disconnected</p></td>
</tr>
<tr class="row-even"><td><p>SIGILL</p></td>
<td><p>The process has executed an illegal instruction (like trying to disable interrupts)</p></td>
</tr>
<tr class="row-odd"><td><p>SIGINT</p></td>
<td><p>Generated by terminal when we press Ctrl-C</p></td>
</tr>
<tr class="row-even"><td><p>SIGAIO</p></td>
<td><p>Generated when an asynchronous I/O event occurs.</p></td>
</tr>
<tr class="row-odd"><td><p>SIGKILL</p></td>
<td><p>Can’t be caught or ignored. Default action is to kill a process.</p></td>
</tr>
<tr class="row-even"><td><p>SIGPIPE</p></td>
<td><p>Generated when you write to a pipe where the reader has been terminated.</p></td>
</tr>
<tr class="row-odd"><td><p>SIGSEGV</p></td>
<td><p>Segmentation violation</p></td>
</tr>
<tr class="row-even"><td><p>SIGSTOP</p></td>
<td><p>Sent before a process is put into the stop state.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="handling-signals-example">
<h2>Handling Signals - Example<a class="headerlink" href="#handling-signals-example" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">handler</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pause</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 7</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">signalNum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">signalNum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIGUSR1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;received SIGUSR1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">signalNum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIGINT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;received SIGHUP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">15</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="sending-signals-example">
<h2>Sending Signals - Example<a class="headerlink" href="#sending-signals-example" title="Permalink to this headline"></a></h2>
<p>Signals can be sent to a running process using kill:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ firefox &amp;
[1] 5050
$ kill -USR1 5050        - sends signal SIGUSR to firefox
$ kill 5050              - sends signal SIGTERM to firefox
</pre></div>
</div>
</section>
<section id="signals-interrupted-system-calls">
<h2>Signals - Interrupted System Calls<a class="headerlink" href="#signals-interrupted-system-calls" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Signals will “wake up” blocking calls to “slow” system calls</p></li>
<li><p>In old UNIX, this was any blocking system call.</p></li>
<li><dl class="simple">
<dt>In modern UNIX, the following are “slow” system calls meaning that they can block for ever in theory:</dt><dd><ul>
<li><p>Reads from pipes, terminal devices, and network devices</p></li>
<li><p>Writes to pipes, terminal devices, and network devices if the data cannot be accepted immediately.</p></li>
<li><p>Opens of files that block until some condition occurs (such as a serial device or modem connecting).</p></li>
<li><p>All calls to the pause() function, pause() waits until signals are caught.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>This means, if you are catching signals, you will have to check errno for EINTR (interrupted by signal) error if these functions return in an error state. If they do, you must retry your operation</p></li>
<li><p>In newer UNIX systems, if signals are triggered with a SA_RESTART flag passed to sigaction(…), system calls would be automatically restarted after signal handling completes.</p></li>
</ul>
</section>
<section id="signals-reentrant-functions">
<h2>Signals - Reentrant Functions<a class="headerlink" href="#signals-reentrant-functions" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>When handling a signal, the main execution of the process is suspended. The interrupted state is not something that can be examined or otherwise determined.</p></li>
<li><p>It is possible that the interrupted state could be inside of a malloc() or free() call. If we call malloc() or free() in the signal handler, we could corrupt the allocated or free list.</p></li>
<li><p>So, in signal handlers we can only call reentrant functions.</p></li>
<li><dl class="simple">
<dt>Reentrant functions have the following properties:</dt><dd><ul>
<li><p>Do not call malloc() or free()</p></li>
<li><p>Do not refer to mutable static data structures</p></li>
<li><p>Rule of thumb is to call functions that are either system calls or low level wrappers of system calls are safe. Other functions should not be used unless you are certain of their safety.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="id2">
<h2>Signals - Reentrant Functions<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">abort</span>       <span class="n">access</span>       <span class="n">alarm</span>      <span class="n">chdir</span>       <span class="n">chmod</span>        <span class="n">chown</span>
<span class="n">close</span>       <span class="n">creat</span>        <span class="n">dup</span>        <span class="n">dup2</span>        <span class="n">execle</span>       <span class="n">execve</span>
<span class="n">exit</span>        <span class="n">fcntl</span>        <span class="n">fork</span>       <span class="n">fstat</span>       <span class="n">getgid</span>       <span class="n">getuid</span>
<span class="n">kill</span>        <span class="n">link</span>         <span class="n">longjmp</span>    <span class="n">lseek</span>       <span class="n">mkdir</span>        <span class="n">mkfifo</span>
<span class="nb">open</span>        <span class="n">pathconf</span>     <span class="n">pause</span>      <span class="n">pipe</span>        <span class="n">read</span>         <span class="n">rename</span>
<span class="n">rmdir</span>       <span class="n">setgid</span>       <span class="n">setsid</span>     <span class="n">setuid</span>      <span class="n">sigaction</span>    <span class="n">sigaddset</span>
<span class="n">sigdelset</span>   <span class="n">sigemptyset</span>  <span class="n">signal</span>     <span class="n">sigpending</span>  <span class="n">sigsuspend</span>   <span class="n">sleep</span>
<span class="n">stat</span>        <span class="n">sysconf</span>      <span class="n">time</span>       <span class="n">times</span>       <span class="n">umask</span>        <span class="n">uname</span>
<span class="n">unlink</span>      <span class="n">utime</span>        <span class="n">wait</span>       <span class="n">waitpid</span>     <span class="n">write</span>
</pre></div>
</div>
</section>
<section id="signals-sending-in-code">
<h2>Signals - Sending In Code<a class="headerlink" href="#signals-sending-in-code" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Sending a signal to another process:</dt><dd><ul>
<li><p>int kill(pid_t pid, int signo);</p></li>
<li><p>pid &gt; 0, signal is sent to process with id = pid</p></li>
<li><p>pid = 0, signal sent to all process whose group ID is the same as the sender of the signal. Will not send to init or swapper daemons.</p></li>
<li><p>pid &lt; 0, signal is sent to all processes whose process group ID equals the absolute value of pid for which the sender has permission to send the signal.</p></li>
<li><p>pid = -1, undefined.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Sending a signal to your own process:</dt><dd><ul>
<li><p>int raise(int signo);</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Sending SIGALRM (terminates process by default):</dt><dd><ul>
<li><p>int alarm(unsigned int seconds);</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Waiting for signals:</dt><dd><ul>
<li><p>int pause(void);</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="example-implementing-sleep-with-alarm">
<h2>Example - implementing sleep() with alarm<a class="headerlink" href="#example-implementing-sleep-with-alarm" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">signo</span><span class="p">)</span><span class="w"> </span>
<span class="linenos"> 2</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">       </span><span class="cm">/* ... */</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sleepFor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numSeconds</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">       </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span><span class="w"> </span><span class="n">sig_alrm</span><span class="p">);</span><span class="w">    </span><span class="c1">//set signal handler</span>
<span class="linenos"> 8</span><span class="w">       </span><span class="n">alarm</span><span class="p">(</span><span class="n">numSeconds</span><span class="p">);</span><span class="w">            </span><span class="c1">//set alarm for n-seconds</span>
<span class="linenos"> 9</span><span class="w">       </span><span class="n">pause</span><span class="p">();</span><span class="w">                      </span><span class="c1">//wait for signal</span>
<span class="linenos">10</span><span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">              </span><span class="c1">//turn off alarm</span>
<span class="linenos">11</span><span class="w">       </span><span class="n">handler</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="example-better-sleep-implementation">
<h2>Example - “better” sleep implementation<a class="headerlink" href="#example-better-sleep-implementation" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">jmpbuf</span><span class="w"> </span><span class="n">env_alrm</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="w"> </span><span class="nf">sig_alrm</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">signo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="n">longjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="n">unsinged</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sleepFor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numSeconds</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span><span class="w"> </span><span class="n">sig_alrm</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">env_alrm</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="n">alarm</span><span class="p">(</span><span class="n">nsecs</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">        </span><span class="n">pause</span><span class="p">();</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="demonstrating-the-sleepfor-problem">
<h2>Demonstrating the sleepFor problem<a class="headerlink" href="#demonstrating-the-sleepfor-problem" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">signo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sig_int enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sig_int done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">    </span><span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="n">sig_int</span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">unslept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sleepFor</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;sleepFor returned: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">unslept</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="p">}</span><span class="w"></span>
<span class="linenos">16</span>
</pre></div>
</div>
</section>
<section id="history-of-sleep-and-why-signals-are-scary">
<h2>History of sleep and why signals are scary.<a class="headerlink" href="#history-of-sleep-and-why-signals-are-scary" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>These two sleep implementations are similar to historical implementations of the sleep() call in UNIX</p></li>
<li><p>Both of these demonstrate that implementations of signal handlers need to be handled with great care.</p></li>
<li><p>You must remember the following between signal and pause: Between the signal registration and the pause call, you may receive the signal. Pause could block forever because of this</p></li>
<li><dl class="simple">
<dt>You must remember the following in signal handlers:</dt><dd><ul>
<li><p>You may be interrupting execution of the main program or another signal handler.</p></li>
<li><p>Avoid modifying global variables</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Avoid non-reentrant functions</dt><dd><ul>
<li><p>Be careful of stack modifying functions like setjmp or longjmp</p></li>
<li><p>If you need this behavior, look towards sigsetjmp or siglongjmp</p></li>
<li><p>Be careful of what signals your handler generates</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="other-uses-for-alarm">
<h2>Other uses for alarm(…)<a class="headerlink" href="#other-uses-for-alarm" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Aside from using alarm() to implement a sleep() call</p></li>
<li><p>alarm() can be used to put an upper time limit on slow or blocking operations.</p></li>
<li><p>If we want to ensure that we don’t wait on a call to read from a named pipe forever, we can setup an alarm call.</p></li>
</ul>
</section>
<section id="memory-mapped-files">
<h2>Memory Mapped Files<a class="headerlink" href="#memory-mapped-files" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Memory mapped files are one of two ways to share memory regions between applications.</p></li>
<li><dl class="simple">
<dt>First, there are some virtual memory concepts that we need to introduce:</dt><dd><ul>
<li><p>Virtual address - the address that the program sees for an object in memory</p></li>
<li><p>Physical address - the real address (if it exists) of an object in physical memory</p></li>
<li><p>Physical and virtual addresses are almost never the same.</p></li>
<li><p>Backing store - the non physical memory location that backs a physical memory object.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>All</strong> physical memory objects have backing stores</dt><dd><ul>
<li><p>text segments - executable and library files</p></li>
<li><p>data, stack segments - swap files</p></li>
<li><p>memory mapped regions - memory mapped files</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>We will dig deeper into virtual memory in a later lecture, but these concepts will be sufficient to proceed</p></li>
</ul>
</section>
<section id="id3">
<h2>Memory Mapped Files<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The technique used in memory mapped files is simple but very powerful.</p></li>
<li><p>Fundamentally, when you memory map a file with the mmap() function, you are declaring a region of virtual memory to be backed by a file.</p></li>
<li><p>This means, when you write to this mapped region, the values will appear (to other programs) immediately in the backing file. If the backing file is updated, the values in that file will (to the running program) appear immediately in memory.</p></li>
<li><p>When two programs map a file into virtual memory, the virtual addresses will most likely differ between the programs.</p></li>
<li><p>Two programs that have the same region of a memory mapped file mapped to memory will be able to communicate with each other by reading and writing values to that memory region</p></li>
</ul>
</section>
<section id="id4">
<h2>Memory Mapped Files<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2>
</section>
<section id="memory-mapped-files-virtual-addresses">
<h2>Memory Mapped Files - Virtual Addresses<a class="headerlink" href="#memory-mapped-files-virtual-addresses" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>There are two instances in virtual memory where position independent code (the use of relative memory addressing) must be used.</p></li>
<li><p>Shared libraries - because the data / bss segments are shared among processes and mapped to different virtual addresses.</p></li>
<li><p>Memory mapped files - because the memory mapped file is mapped to different virtual addresses in different processes.</p></li>
<li><p>To implement position independent code, techniques similar to -fpic used in GCC must be used by code that you write to work with memory mapped regions.</p></li>
<li><dl class="simple">
<dt>Rules for writing position independent code in memory mapped regions:</dt><dd><ul>
<li><p>Do not pass pointers or structures that make use of pointers. Pointers use virtual addresses.</p></li>
<li><p>Objects in memory mapped regions should not refer to objects outside of memory mapped regions.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="absolute-memory-addressing">
<h2>Absolute Memory Addressing<a class="headerlink" href="#absolute-memory-addressing" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="n">Brand</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">TractionRating</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">SpeedRating</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">}</span><span class="w"> </span><span class="n">Wheel</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">Wheel</span><span class="o">*</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">Wheels</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">Make</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">Model</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="p">}</span><span class="w"> </span><span class="n">Car</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="n">Car</span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Car</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Car</span><span class="p">));</span><span class="w"></span>
<span class="linenos">14</span><span class="n">car</span><span class="p">.</span><span class="n">Make</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="n">car</span><span class="p">.</span><span class="n">Model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="mi">50</span><span class="p">);</span><span class="w"></span>
<span class="linenos">16</span><span class="n">car</span><span class="p">.</span><span class="n">Wheels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Wheel</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Wheel</span><span class="p">));</span><span class="w"></span>
<span class="linenos">17</span><span class="n">car</span><span class="p">.</span><span class="n">Wheels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Wheel</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Wheel</span><span class="p">));</span><span class="w"></span>
<span class="linenos">18</span><span class="n">car</span><span class="p">.</span><span class="n">Wheels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Wheel</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Wheel</span><span class="p">));</span><span class="w"></span>
<span class="linenos">19</span><span class="n">car</span><span class="p">.</span><span class="n">Wheels</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Wheel</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Wheel</span><span class="p">));</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="n">car</span><span class="p">.</span><span class="n">Wheels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Brand</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the location of each of the wheel objects is stored with an absolute reference from the Car. If this is shared in a memory mapped file, a call to car.Wheels[0] will not resolve to a correct address.</p>
</section>
<section id="relative-memory-addressing">
<h2>Relative Memory Addressing<a class="headerlink" href="#relative-memory-addressing" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="n">Brand</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">TractionRating</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">SpeedRating</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">}</span><span class="w"> </span><span class="n">Wheel</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">Wheel</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">Wheels</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="n">Make</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">char</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="n">Model</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="p">}</span><span class="w"> </span><span class="n">Car</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="n">Car</span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Car</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Car</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>Here, we are using relative addressing. The entire Car struct is allocated in a contiguous memory region. To access each wheel, you need only use an offset from the beginning of the Car struct.</p>
</section>
<section id="linux-minix-use-of-mmap">
<h2>Linux / Minix - Use of mmap()<a class="headerlink" href="#linux-minix-use-of-mmap" title="Permalink to this headline"></a></h2>
<p>General Algorithm:</p>
<ol class="arabic simple">
<li><p>Process A creates file on disk</p></li>
<li><p>Process A seeks a length of N</p></li>
<li><p>Process A writes a 0 to the file</p></li>
<li><p>Process A calls mmap on the file to map it to memory</p></li>
<li><p>Process A copies its data structures into the mapped region</p></li>
<li><p>Process B calls mmap on the file to map it to memory</p></li>
<li><p>Process A and B proceed using the mapped region to cooperate</p></li>
</ol>
</section>
<section id="mmap-simple-example">
<h2>mmap - simple example<a class="headerlink" href="#mmap-simple-example" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dummyValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;shared.dat&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="o">|</span><span class="n">O_RDWR</span><span class="p">,</span><span class="w"> </span><span class="mo">0666</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">    </span><span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"> </span><span class="n">SEEK_SET</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummyValue</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">    </span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">dataSize</span><span class="p">,</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">    </span><span class="n">getchar</span><span class="p">();</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">    </span><span class="n">munmap</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="p">}</span><span class="w"></span>
<span class="linenos">21</span>
</pre></div>
</div>
</section>
<section id="id6">
<h2>mmap - simple example<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="k">struct</span> <span class="nc">stat</span><span class="w"> </span><span class="n">fileStat</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="n">stat</span><span class="p">(</span><span class="s">&quot;shared.dat&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fileStat</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fileSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fileStat</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;shared.dat&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">fileSize</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">fileSize</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">fileSize</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">    </span><span class="n">munmap</span><span class="p">(</span><span class="n">map</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">21</span><span class="p">}</span><span class="w"></span>
<span class="linenos">22</span>
</pre></div>
</div>
</section>
<section id="memory-mapped-files-atomicity">
<h2>Memory Mapped Files - Atomicity<a class="headerlink" href="#memory-mapped-files-atomicity" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>When we explored pipes, we learned that writing to a pipe (below a certain limit) is an atomic operation. We get this guarantee because the OS kernel guarantees this by guaranteeing that system calls are atomic.</p></li>
<li><p>The only system calls involved in memory mapped files are mmap and munmap. These are only for initializing and cleaning up mapped memory regions.</p></li>
<li><p>Reading and writing mapped memory regions does not involve system calls and carries no guarantee of atomicity. It is similar to multiple threads writing to the same heap.</p></li>
<li><dl class="simple">
<dt>To achieve atomicity in memory mapped regions, you must use:</dt><dd><ul>
<li><p>Mutexes</p></li>
<li><p>Semaphores</p></li>
<li><p>Monitors / Condition Variables</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The implementation that you use must also use relative addressing internally or otherwise be able to be configured for it.</p></li>
<li><p>The fact that memory mapped regions do not guarantee atomicity and do not use context switches is also why memory mapped regions perform so well.</p></li>
<li><p>In general, the fewer the guarantees a mechanism provides, the faster it is.</p></li>
</ul>
</section>
<section id="memory-mapped-files-bounded-buffer">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#memory-mapped-files-bounded-buffer" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MessageQueueSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MaxMessageSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="n">class</span><span class="w"> </span><span class="n">Message</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 7</span><span class="nl">public</span><span class="p">:</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">  </span><span class="o">~</span><span class="n">Message</span><span class="p">();</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">EnqueueMessage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">DequeueMessage</span><span class="p">();</span><span class="w"></span>
<span class="linenos">11</span><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="nf">CopyToMemoryMappedFile</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="nf">GetFromMemoryMappedFile</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">ReleaseFile</span><span class="p">(</span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="nl">private</span><span class="p">:</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="n">Message</span><span class="p">();</span><span class="w"></span>
<span class="linenos">16</span><span class="w">  </span><span class="n">sem_t</span><span class="w"> </span><span class="n">_lock</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w">  </span><span class="n">sem_t</span><span class="w"> </span><span class="n">_empty</span><span class="p">;</span><span class="w"></span>
<span class="linenos">18</span><span class="w">  </span><span class="n">sem_t</span><span class="w"> </span><span class="n">_full</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">_current</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">_messages</span><span class="p">[</span><span class="n">MessageQueueSize</span><span class="p">][</span><span class="n">MaxMessageSize</span><span class="p">];</span><span class="w"></span>
<span class="linenos">21</span><span class="p">};</span><span class="w"></span>
<span class="linenos">22</span>
</pre></div>
</div>
</section>
<section id="id7">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">Message</span><span class="o">::</span><span class="n">Message</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_lock</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">                                </span><span class="c1">//passing 1 as the 2nd parameter allows the</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_empty</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">                              </span><span class="c1">//semaphore work in a memory mapped region</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_full</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MessageQueueSize</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">_current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 7</span><span class="n">Message</span><span class="o">::~</span><span class="n">Message</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 8</span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="n">Message</span><span class="o">::</span><span class="n">CopyToMemoryMappedFile</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">datasize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;message size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">datasize</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">),</span><span class="w"> </span><span class="n">SEEK_SET</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">     </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;error in lseek</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">14</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">dummyVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dummyVal</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">16</span><span class="w">     </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;error in write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">18</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">),</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">20</span><span class="w">     </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mmap() returned -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">22</span><span class="w">  </span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Message</span><span class="p">();</span><span class="w"></span>
<span class="linenos">23</span><span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">));</span><span class="w"></span>
<span class="linenos">24</span><span class="w">  </span><span class="n">delete</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">Message</span><span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="p">;</span><span class="w"></span>
<span class="linenos">26</span><span class="p">}</span><span class="w"></span>
<span class="linenos">27</span>
</pre></div>
</div>
</section>
<section id="id8">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="nf">Message::GetFromMemoryMappedFile</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">     </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">),</span><span class="w"> </span>
<span class="linenos"> 4</span><span class="w">     </span><span class="p">(</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">),</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">     </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mmap() returned -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">  </span><span class="n">Message</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Message</span><span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="p">}</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="kt">void</span><span class="w"> </span><span class="nf">Message::ReleaseFile</span><span class="p">(</span><span class="n">Message</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">13</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">munmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Message</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">14</span><span class="w">     </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;munmap() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">16</span><span class="p">}</span><span class="w"></span>
<span class="linenos">17</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="id9">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">Message::EnqueueMessage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_full</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_lock</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">_current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_messages</span><span class="p">[</span><span class="n">_current</span><span class="p">],</span><span class="w"> </span><span class="n">MaxMessageSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_messages</span><span class="p">[</span><span class="n">_current</span><span class="p">],</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_lock</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">  </span><span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_empty</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="p">}</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">Message::DequeueMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">MaxMessageSize</span><span class="p">];</span><span class="w"></span>
<span class="linenos">13</span><span class="w">  </span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_empty</span><span class="p">);</span><span class="w"></span>
<span class="linenos">14</span><span class="w">  </span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_lock</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_messages</span><span class="p">[</span><span class="n">_current</span><span class="p">],</span><span class="w"> </span><span class="n">MaxMessageSize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span><span class="w"></span>
<span class="linenos">16</span><span class="w">  </span><span class="n">_current</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w">  </span><span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_lock</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">  </span><span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_full</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span><span class="p">}</span><span class="w"></span>
<span class="linenos">21</span>
</pre></div>
</div>
</section>
<section id="id10">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2>
<p>Producer Code</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sharedFileName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;shared.dat&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">mode_t</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0666</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">openFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">O_CREAT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">O_TRUNC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="n">sharedFileName</span><span class="p">,</span><span class="w"> </span><span class="n">openFlags</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;open returned (-1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">Message</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span><span class="o">::</span><span class="n">CopyToMemoryMappedFile</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">15</span><span class="w">     </span><span class="kt">char</span><span class="w"> </span><span class="n">message</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w"></span>
<span class="linenos">16</span><span class="w">     </span><span class="n">sprintf</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">EnqueueMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;enqueued %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">20</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;message queue written</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">  </span><span class="n">getchar</span><span class="p">();</span><span class="w"></span>
<span class="linenos">22</span><span class="w">  </span><span class="n">Message</span><span class="o">::</span><span class="n">ReleaseFile</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span><span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id11">
<h2>Memory Mapped Files - Bounded Buffer<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2>
<p>Consumer Code</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sharedFileName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;shared.dat&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">mode_t</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0666</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">openFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">O_RDWR</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="n">sharedFileName</span><span class="p">,</span><span class="w"> </span><span class="n">openFlags</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;open returned (-1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">Message</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span><span class="o">::</span><span class="n">GetFromMemoryMappedFile</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">DequeueMessage</span><span class="p">();</span><span class="w"></span>
<span class="linenos">18</span><span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span><span class="w"></span>
<span class="linenos">20</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">  </span><span class="n">Message</span><span class="o">::</span><span class="n">ReleaseFile</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">25</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-mapped-files-fast-i-o">
<h2>Memory Mapped Files - Fast I/O<a class="headerlink" href="#memory-mapped-files-fast-i-o" title="Permalink to this headline"></a></h2>
<p>Memory mapped I/O is faster because it avoids a copy from user mode to kernel mode</p>
<p>Normal User - Kernel write(…) call algorithm:</p>
<ol class="arabic simple">
<li><p>user app - write(fd, user_buf, len);</p></li>
<li><p>user app - context switch into OS (software interrupt)</p></li>
<li><p>kernel mode - allocate space in file, check security, etc…</p></li>
<li><p>kernel mode - copy user_buf to FS buffer cache</p></li>
<li><p>kernel mode - context switch into user app (interrupt return)</p></li>
<li><p>at some later time, kernel commits buffer cache to disk</p></li>
</ol>
<p>Normal User - Kernel mmap(…) write algorithm:</p>
<ol class="arabic simple">
<li><p>user app - copy values to mapped region</p></li>
<li><p>kernel mode - MMU triggers page fault (hardware interrupt)</p></li>
<li><p>kernel mode - writes page to backing store</p></li>
<li><p>kernel mode - context switch to user app (interrupt return)</p></li>
</ol>
</section>
<section id="id12">
<h2>Memory Mapped Files - Fast I/O<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The read algorithm for regular read vs. mmap read is very similar to the write algorithm and also avoids a kernel to user mode copy</p></li>
<li><p>On systems with large address spaces (64-bit), memory mapped I/O can be very advantageous. - For example, a database server can memory map an entire database that is several TB in size into memory.</p></li>
<li><p>Since most VM systems user a very efficient LRU algorithm and have a lot of I/O scheduling data, memory mapping large files is amongst the fastest approaches.</p></li>
<li><p>Other advanced approaches include scatter/gather or vectored I/O.</p></li>
<li><p>Memory mapped I/O carries the greatest advantage when the structure of the file maps well into the domain model. This means that no serialization / deserialization is needed.</p></li>
</ul>
</section>
<section id="files-ipc">
<h2>Files - IPC<a class="headerlink" href="#files-ipc" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Files are the oldest and most generally used form of IPC</p></li>
<li><p>Almost every resource in a modern operating system is accessible through a file based contract (open, read, write, seek, close)</p></li>
<li><p>File based IPC is available in almost every operating system.</p></li>
<li><dl class="simple">
<dt>File based IPC, in modern times is best considered in a few patterns:</dt><dd><ul>
<li><p>State persistence - beyond the lifetime of a program</p></li>
<li><p>Exposing current state - during program execution</p></li>
<li><p>Queues / Spooling folders - mail daemons, printers, execution queues</p></li>
<li><p>Resource state expression - lock files, availability, etc…</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="files-exposing-current-state">
<h2>Files - Exposing Current State<a class="headerlink" href="#files-exposing-current-state" title="Permalink to this headline"></a></h2>
<p>/proc filesystems are important ways for OS designers to expose system
information without inventing new system calls.</p>
<ul class="simple">
<li><p>This is a key advantage for kernel module developers and for device driver developers</p></li>
<li><p>Also provides a great way to debug kernel changes</p></li>
</ul>
<table class="colwidths-given docutils align-default" id="id16">
<caption><span class="caption-text">List of /proc-style Filesystems</span><a class="headerlink" href="#id16" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Filesystem</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Filesystem</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-odd"><td><p>/proc/vmstat</p></td>
<td><p>virtual memory stats and configuration</p></td>
</tr>
<tr class="row-even"><td><p>/proc/cpuinfo</p></td>
<td><p>individual CPU information</p></td>
</tr>
<tr class="row-odd"><td><p>/proc/&lt;PID&gt;</p></td>
<td><p>individual process information</p></td>
</tr>
<tr class="row-even"><td><p>/proc/loadavg</p></td>
<td><p>moving average of ready process load</p></td>
</tr>
</tbody>
</table>
</section>
<section id="spool-folders">
<h2>Spool Folders<a class="headerlink" href="#spool-folders" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Spool folders are most commonly used for:</dt><dd><ul>
<li><p>E-mail daemons (Postfix, Exchange, etc…)</p></li>
<li><p>Printer managers (CUPS, lpr, etc…)</p></li>
<li><p>Job managers (CRON, etc…)</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Spool folders are folders reserved for a single process that’s single task is to monitor the folder and process each new file created in the folder. Each file in the folder represents a task to complete.</p></li>
<li><p>Spool folders, like other persisted queueing systems are resilient to failure. If the processing daemon crashes, it can be restarted without losing the task list.</p></li>
<li><p>Often, spool folders are processed by some defined order. One typical order is to process files alphabetically.</p></li>
<li><p>If the jobs are not meant to be repeated, files are typically moved to another folder upon completion or deleted.</p></li>
</ul>
</section>
<section id="spool-folders-cron">
<h2>Spool Folders - Cron<a class="headerlink" href="#spool-folders-cron" title="Permalink to this headline"></a></h2>
<p>Cron typically maintains a few spool folders under /etc:</p>
<ul class="simple">
<li><p>/etc/cron.daily</p></li>
<li><p>/etc/cron.hourly</p></li>
<li><p>/etc/cron.monthly</p></li>
<li><p>/etc/cron.weekly</p></li>
</ul>
<p>Cron will, at the correct time, enter each of these folders and execute every executable file in each of these folders.</p>
</section>
<section id="spool-folders-cups">
<h2>Spool Folders - CUPS<a class="headerlink" href="#spool-folders-cups" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>CUPS is a printer daemon for UNIX operating systems</p></li>
<li><p>The spool folder for CUPS is typically /var/spool/cups</p></li>
<li><dl class="simple">
<dt>In the spool folder there are two types of files:</dt><dd><ul>
<li><dl class="simple">
<dt>Data files - The object that is being printed</dt><dd><ul>
<li><p>Named d00001-001, d00001-002, d00002-001,….</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Control files - A file that represents a set of data files</dt><dd><ul>
<li><p>Named c00001, c00002, ….</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>The use of this file naming convention exposes a domain model of sorts that the CUPS system respects in its queue.</p></li>
<li><p>CUPS has a series of programs that manage the creation of files in the spooling folder and the processing of files once in the spooling folder.</p></li>
</ul>
</section>
<section id="lock-files">
<h2>Lock Files<a class="headerlink" href="#lock-files" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>A useful aspect of all system calls is that they are atomic operations. This means that some system calls can be used to perform test-and-set like operations and be the basis of locking systems.</p></li>
<li><dl class="simple">
<dt>A common example is the use of files to make sure only one instance of a software program is running at one time.</dt><dd><ul>
<li><p>For example, you would not want to HTTP daemons running on the same port.</p></li>
<li><p>To prevent this, you could create a lock file like /var/lock/http_80.</p></li>
<li><p>When the HTTP daemon starts up, it can check very early on for a /var/lock/http_## for the port it is configured on before proceeding. When the daemon shuts down it can delete the file</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The creation of and deletion of files is an atomic operation. So, if two processes both try at the same time to create the same file, only one will succeed.</p></li>
</ul>
</section>
<section id="doors">
<h2>Doors<a class="headerlink" href="#doors" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Doors pretty much only exist on Solaris and nowhere else</p></li>
<li><p>Even so, they are an interesting concept.</p></li>
<li><p>Doors basically allow a process to expose one or more functions through one or more files on the filesystem. It is basically a file system based RPC mechanism</p></li>
</ul>
</section>
<section id="server-code">
<h2>Server Code<a class="headerlink" href="#server-code" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">server</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">cookie</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argp</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">arg_size</span><span class="p">,</span><span class="w"> </span><span class="n">door_desc_t</span><span class="o">*</span><span class="w"> </span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">uint_t</span><span class="w"> </span><span class="n">n_desc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w">    </span><span class="cm">/*server code goes here*/</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="p">}</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="kt">int</span><span class="w"> </span><span class="n">doorfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">door_create</span><span class="p">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">creat</span><span class="p">(</span><span class="s">&quot;/tmp/door&quot;</span><span class="p">,</span><span class="w"> </span><span class="mo">0666</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 9</span><span class="n">fdetach</span><span class="p">(</span><span class="s">&quot;/tmp/door&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="n">fattach</span><span class="p">(</span><span class="n">doorfd</span><span class="p">,</span><span class="s">&quot;/tmp/door&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="n">pause</span><span class="p">();</span><span class="w"></span>
<span class="linenos">12</span>
</pre></div>
</div>
</section>
<section id="client-code">
<h2>Client Code<a class="headerlink" href="#client-code" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">typdef</span><span class="w"> </span><span class="k">struct</span> <span class="nc">myArg</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"></span>
<span class="linenos"> 3</span><span class="p">}</span><span class="w"> </span><span class="n">myArg_t</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="n">door_arg_t</span><span class="w"> </span><span class="n">d_arg</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="kt">int</span><span class="w"> </span><span class="n">doorfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/tmp/door&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="n">myArg_t</span><span class="o">*</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">myArg_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">myArg_t</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 8</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="n">d_arg</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="n">d_arg</span><span class="p">.</span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="n">d_arg</span><span class="p">.</span><span class="n">desc_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="n">d_arg</span><span class="p">.</span><span class="n">desc_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="n">door_call</span><span class="p">(</span><span class="n">doorfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_arg</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="domain-sockets">
<h2>Domain Sockets<a class="headerlink" href="#domain-sockets" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>Domain sockets serve the same purpose as named pipes, except that domain sockets are:</dt><dd><ul>
<li><p>Full - duplex</p></li>
<li><p>Can have many clients to one server</p></li>
<li><p>Support datagram and streaming modes</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Domain sockets use functions that are very similar to what is used with internet sockets:</dt><dd><ul>
<li><p>accept, bind, listen, connect, socket</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The setup for domain sockets can be a bit complex, so the best way to explain is through a simple example.</p></li>
</ul>
</section>
<section id="domain-sockets-example">
<h2>Domain Sockets - Example<a class="headerlink" href="#domain-sockets-example" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">server_listen</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fileName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="n">unlink</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">socket_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">PF_UNIX</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="w"> </span><span class="n">address</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">  </span><span class="n">address</span><span class="p">.</span><span class="n">sun_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_UNIX</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">sprintf</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">sun_path</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">bind</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="p">));</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="n">listen</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos">11</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">connection_fd</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">address_length</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="w">  </span><span class="k">while</span><span class="p">((</span><span class="n">connection_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accept</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">address_length</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">14</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span><span class="w"></span>
<span class="linenos">15</span><span class="w">     </span><span class="k">if</span><span class="p">(</span><span class="n">child</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">16</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">connection_handler</span><span class="p">(</span><span class="n">connection_fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">18</span><span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">connection_fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="p">}</span><span class="w"> </span>
<span class="linenos">20</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">23</span><span class="w">  </span><span class="n">unlink</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span><span class="w"></span>
<span class="linenos">24</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id13">
<h2>Domain Sockets - Example<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">connection_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">socket_fd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buff</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">  </span><span class="n">buff</span><span class="p">[</span><span class="n">nBytes</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;message from client: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">buff</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">  </span><span class="n">nBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">snprintf</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello from server&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">write</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="n">nBytes</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="p">}</span><span class="w"></span>
<span class="linenos">12</span>
</pre></div>
</div>
</section>
<section id="id14">
<h2>Domain Sockets - Example<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span><span class="w"> </span><span class="nf">client_connect</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fileName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">socket_fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">PF_UNIX</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="w">  </span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="w"> </span><span class="n">address</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">  </span><span class="n">address</span><span class="p">.</span><span class="n">sun_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_UNIX</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">sprintf</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">sun_path</span><span class="p">,</span><span class="w"> </span><span class="n">fileName</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="n">connect</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_un</span><span class="p">));</span><span class="w"></span>
<span class="linenos">10</span><span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
<span class="linenos">11</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello from a client&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">  </span><span class="n">write</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">nBytes</span><span class="p">);</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">  </span><span class="n">nBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">);</span><span class="w"></span>
<span class="linenos">15</span><span class="w">  </span><span class="n">buffer</span><span class="p">[</span><span class="n">nBytes</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;message from server: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">);</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">22</span><span class="p">}</span><span class="w"></span>
<span class="linenos">23</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="deadlock.html" class="btn btn-neutral float-left" title="Deadlock" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kernelmm.html" class="btn btn-neutral float-right" title="Virtual Memory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2020, Operating Systems Faculty at Loyola University Chicago.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>