<!DOCTYPE html>

<html :class="{'dark': darkMode === 'dark' || (darkMode === 'system' &amp;&amp; window.matchMedia('(prefers-color-scheme: dark)').matches)}" class="scroll-smooth" lang="en" x-data="{ darkMode: localStorage.getItem('darkMode') || localStorage.setItem('darkMode', 'system'), activeSection: '' }" x-init="$watch('darkMode', val =&gt; localStorage.setItem('darkMode', val))">
<head>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta charset="utf-8"/>
<meta content="white" media="(prefers-color-scheme: light)" name="theme-color"/>
<meta content="black" metia="(prefers-color-scheme: dark)" name="theme-color"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Userland Memory Management | Operating Systems: updated 04 Dec 2023</title>
<meta content="Userland Memory Management | Operating Systems: updated 04 Dec 2023" property="og:title"/>
<meta content="Userland Memory Management | Operating Systems: updated 04 Dec 2023" name="twitter:title"/>
<link href="_static/pygments.css" rel="stylesheet"/>
<link href="_static/theme.css" rel="stylesheet"/>
<link href="search.html" rel="search" title="Search"/>
<link href="genindex.html" rel="index" title="Index"/>
<link href="storage.html" rel="next" title="Storage and Devices"/>
<link href="kernelmm.html" rel="prev" title="Virtual Memory"/>
<script>
    <!-- Prevent Flash of wrong theme -->
      const userPreference = localStorage.getItem('darkMode');
      let mode;
      if (userPreference === 'dark' || window.matchMedia('(prefers-color-scheme: dark)').matches) {
        mode = 'dark';
        document.documentElement.classList.add('dark');
      } else {
        mode = 'light';
      }
      if (!userPreference) {localStorage.setItem('darkMode', mode)}
    </script>
<script src="_static/documentation_options.js?v=a0bb73f4"></script>
<script src="_static/doctools.js?v=888ff710"></script>
<script src="_static/sphinx_highlight.js?v=dc90522c"></script>
<script defer="" src="_static/theme.ad172c0f1249198ea036.js"></script>
</head>
<body :class="{ 'overflow-hidden': showSidebar }" class="min-h-screen font-sans antialiased bg-background text-foreground" x-data="{ showSidebar: false }">
<div @click.self="showSidebar = false" class="fixed inset-0 z-50 overflow-hidden bg-background/80 backdrop-blur-sm" x-cloak="" x-show="showSidebar"></div><div class="relative flex flex-col min-h-screen" id="page"><a class="absolute top-0 left-0 z-[100] block bg-background p-4 text-xl transition -translate-x-full opacity-0 focus:translate-x-0 focus:opacity-100" href="#content">
      Skip to content
    </a><header class="sticky top-0 z-40 w-full border-b shadow-sm border-border supports-backdrop-blur:bg-background/60 bg-background/95 backdrop-blur"><div class="container flex items-center h-14">
<div class="hidden mr-4 md:flex">
<a class="flex items-center mr-6" href="index.html"><span class="hidden font-bold sm:inline-block text-clip whitespace-nowrap">Operating Systems: updated 04 Dec 2023</span>
</a></div><button @click="showSidebar = true" class="inline-flex items-center justify-center h-10 px-0 py-2 mr-2 text-base font-medium transition-colors rounded-md hover:text-accent-foreground hover:bg-transparent md:hidden" type="button">
<svg aria-hidden="true" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M152.587 825.087q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440Zm0-203.587q-19.152 0-32.326-13.174T107.087 576q0-19.152 13.174-32.326t32.326-13.174h320q19.152 0 32.326 13.174T518.087 576q0 19.152-13.174 32.326T472.587 621.5h-320Zm0-203.587q-19.152 0-32.326-13.174t-13.174-32.326q0-19.152 13.174-32.326t32.326-13.174h440q19.152 0 32.326 13.174t13.174 32.326q0 19.152-13.174 32.326t-32.326 13.174h-440ZM708.913 576l112.174 112.174q12.674 12.674 12.674 31.826t-12.674 31.826Q808.413 764.5 789.261 764.5t-31.826-12.674l-144-144Q600 594.391 600 576t13.435-31.826l144-144q12.674-12.674 31.826-12.674t31.826 12.674q12.674 12.674 12.674 31.826t-12.674 31.826L708.913 576Z"></path>
</svg>
<span class="sr-only">Toggle navigation menu</span>
</button>
<div class="flex items-center justify-between flex-1 space-x-2 sm:space-x-4 md:justify-end">
<div class="flex-1 w-full md:w-auto md:flex-none">
<form @keydown.k.window.meta="$refs.search.focus()" action="search.html" class="relative flex items-center group" id="searchbox" method="get">
<input aria-label="Search the docs" class="inline-flex items-center font-medium transition-colors bg-transparent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 ring-offset-background border border-input hover:bg-accent focus:bg-accent hover:text-accent-foreground focus:text-accent-foreground hover:placeholder-accent-foreground py-2 px-4 relative h-9 w-full justify-start rounded-[0.5rem] text-sm text-muted-foreground sm:pr-12 md:w-40 lg:w-64" id="search-input" name="q" placeholder="Search ..." type="search" x-ref="search"/>
<kbd class="pointer-events-none absolute right-1.5 top-2 hidden h-5 select-none text-muted-foreground items-center gap-1 rounded border border-border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex group-hover:bg-accent group-hover:text-accent-foreground">
<span class="text-xs">⌘</span>
      K
    </kbd>
</form>
</div>
<nav class="flex items-center space-x-1">
<button @click="darkMode = darkMode === 'light' ? 'dark' : 'light'" class="relative inline-flex items-center justify-center px-0 text-sm font-medium transition-colors rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9" type="button">
<svg class="absolute transition-all scale-100 rotate-0 dark:-rotate-90 dark:scale-0" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 685q45.456 0 77.228-31.772Q589 621.456 589 576q0-45.456-31.772-77.228Q525.456 467 480 467q-45.456 0-77.228 31.772Q371 530.544 371 576q0 45.456 31.772 77.228Q434.544 685 480 685Zm0 91q-83 0-141.5-58.5T280 576q0-83 58.5-141.5T480 376q83 0 141.5 58.5T680 576q0 83-58.5 141.5T480 776ZM80 621.5q-19.152 0-32.326-13.174T34.5 576q0-19.152 13.174-32.326T80 530.5h80q19.152 0 32.326 13.174T205.5 576q0 19.152-13.174 32.326T160 621.5H80Zm720 0q-19.152 0-32.326-13.174T754.5 576q0-19.152 13.174-32.326T800 530.5h80q19.152 0 32.326 13.174T925.5 576q0 19.152-13.174 32.326T880 621.5h-80Zm-320-320q-19.152 0-32.326-13.174T434.5 256v-80q0-19.152 13.174-32.326T480 130.5q19.152 0 32.326 13.174T525.5 176v80q0 19.152-13.174 32.326T480 301.5Zm0 720q-19.152 0-32.326-13.17Q434.5 995.152 434.5 976v-80q0-19.152 13.174-32.326T480 850.5q19.152 0 32.326 13.174T525.5 896v80q0 19.152-13.174 32.33-13.174 13.17-32.326 13.17ZM222.174 382.065l-43-42Q165.5 327.391 166 308.239t13.174-33.065q13.435-13.674 32.587-13.674t32.065 13.674l42.239 43q12.674 13.435 12.555 31.706-.12 18.272-12.555 31.946-12.674 13.674-31.445 13.413-18.772-.261-32.446-13.174Zm494 494.761-42.239-43q-12.674-13.435-12.674-32.087t12.674-31.565Q686.609 756.5 705.38 757q18.772.5 32.446 13.174l43 41.761Q794.5 824.609 794 843.761t-13.174 33.065Q767.391 890.5 748.239 890.5t-32.065-13.674Zm-42-494.761Q660.5 369.391 661 350.62q.5-18.772 13.174-32.446l41.761-43Q728.609 261.5 747.761 262t33.065 13.174q13.674 13.435 13.674 32.587t-13.674 32.065l-43 42.239q-13.435 12.674-31.706 12.555-18.272-.12-31.946-12.555Zm-495 494.761Q165.5 863.391 165.5 844.239t13.674-32.065l43-42.239q13.435-12.674 32.087-12.674t31.565 12.674Q299.5 782.609 299 801.38q-.5 18.772-13.174 32.446l-41.761 43Q231.391 890.5 212.239 890t-33.065-13.174ZM480 576Z"></path>
</svg>
<svg class="absolute transition-all scale-0 rotate-90 dark:rotate-0 dark:scale-100" fill="currentColor" height="24" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 936q-151 0-255.5-104.5T120 576q0-138 90-239.5T440 218q25-3 39 18t-1 44q-17 26-25.5 55t-8.5 61q0 90 63 153t153 63q31 0 61.5-9t54.5-25q21-14 43-1.5t19 39.5q-14 138-117.5 229T480 936Zm0-80q88 0 158-48.5T740 681q-20 5-40 8t-40 3q-123 0-209.5-86.5T364 396q0-20 3-40t8-40q-78 32-126.5 102T200 576q0 116 82 198t198 82Zm-10-270Z"></path>
</svg>
</button>
</nav>
</div>
</div>
</header>
<div class="flex-1"><div class="container flex-1 items-start md:grid md:grid-cols-[220px_minmax(0,1fr)] md:gap-6 lg:grid-cols-[240px_minmax(0,1fr)] lg:gap-10"><aside :aria-hidden="!showSidebar" :class="{ 'translate-x-0': showSidebar }" class="fixed inset-y-0 left-0 md:top-14 z-50 md:z-30 bg-background md:bg-transparent transition-all duration-100 -translate-x-full md:translate-x-0 ml-0 p-6 md:p-0 md:-ml-2 md:h-[calc(100vh-3.5rem)] w-5/6 md:w-full shrink-0 overflow-y-auto border-r border-border md:sticky" id="left-sidebar">
<a class="!justify-start text-sm md:!hidden bg-background" href="index.html"><span class="font-bold text-clip whitespace-nowrap">Operating Systems: updated 04 Dec 2023</span>
</a>
<div class="relative overflow-hidden md:overflow-auto my-4 md:my-0 h-[calc(100vh-8rem)] md:h-auto">
<div class="overflow-y-auto h-full w-full relative pr-6"><nav class="table w-full min-w-full my-6 lg:my-8">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="meta.html">About the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Introduction to Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="files-io.html">Files and I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduling.html">Process/Thread Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutualexclusion.html">Mutual Exclusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="deadlock.html">Deadlock</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipc.html">IPC Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernelmm.html">Virtual Memory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Userland Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">Storage and Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">Implementing Files and Folders</a></li>
<li class="toctree-l1"><a class="reference internal" href="research.html">Storage Research at Loyola</a></li>
<li class="toctree-l1"><a class="reference internal" href="linux_vm.html">Installing a Linux Virtual Machine with VMware</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows_vm.html">Installing a Windows Virtual Machine with VMware</a></li>
</ul>
</nav>
</div>
</div>
<button @click="showSidebar = false" class="absolute md:hidden right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100" type="button">
<svg class="h-4 w-4" fill="currentColor" height="24" stroke="none" viewbox="0 96 960 960" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M480 632 284 828q-11 11-28 11t-28-11q-11-11-11-28t11-28l196-196-196-196q-11-11-11-28t11-28q11-11 28-11t28 11l196 196 196-196q11-11 28-11t28 11q11 11 11 28t-11 28L536 576l196 196q11 11 11 28t-11 28q-11 11-28 11t-28-11L480 632Z"></path>
</svg>
</button>
</aside>
<main class="relative py-6 lg:gap-10 lg:py-8 xl:grid xl:grid-cols-[1fr_300px]">
<div class="w-full min-w-0 mx-auto">
<nav aria-label="breadcrumbs" class="flex items-center mb-4 space-x-1 text-sm text-muted-foreground">
<a class="overflow-hidden text-ellipsis whitespace-nowrap hover:text-foreground" href="index.html">
<span class="hidden md:inline">Operating Systems: updated 04 Dec 2023</span>
<svg aria-label="Home" class="md:hidden" fill="currentColor" height="18" stroke="none" viewbox="0 96 960 960" width="18" xmlns="http://www.w3.org/2000/svg">
<path d="M240 856h120V616h240v240h120V496L480 316 240 496v360Zm-80 80V456l320-240 320 240v480H520V696h-80v240H160Zm320-350Z"></path>
</svg>
</a>
<div class="mr-1">/</div><span aria-current="page" class="font-medium text-foreground overflow-hidden text-ellipsis whitespace-nowrap">Userland Memory Management</span>
</nav>
<div id="content" role="main">
<section id="userland-memory-management">
<h1>Userland Memory Management<a class="headerlink" href="#userland-memory-management" title="Link to this heading">¶</a></h1>
<section id="why-userland-memory-management">
<h2>Why Userland Memory Management?<a class="headerlink" href="#why-userland-memory-management" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#why-userland-memory-management'">¶</a></h2>
<ul class="simple">
<li><p>Why discuss user land memory management in an OS course?</p></li>
<li><p>After all, user land memory management is almost always an
implementation detail of a standard library or virtual machine.</p></li>
<li><p>The reason that this is important is that the OS allocates to user
programs memory as units of contiguous virtual pages.</p></li>
<li><p>The unit of the page is not very useful for many programs. Most
programs work in terms of structured objects that are composed of
primitive data types and pointers to other structured objects or
primitive data types.</p></li>
</ul>
</section>
<section id="id1">
<h2>Why Userland Memory Management?<a class="headerlink" href="#id1" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id1'">¶</a></h2>
<ul class="simple">
<li><p>Because programs need a view of the machine as something other than
pages, we can consider the topic of user land memory management as a
detail of the virtual machine that the system provides.</p></li>
<li><p>Because the details of the memory management system differ based on
language needs, it is impractical for this component to exist within
the operating system implementation.</p></li>
</ul>
</section>
<section id="heap-management">
<h2>Heap Management<a class="headerlink" href="#heap-management" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#heap-management'">¶</a></h2>
</section>
<section id="the-heap">
<h2>The Heap<a class="headerlink" href="#the-heap" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#the-heap'">¶</a></h2>
<ul class="simple">
<li><p>The heap is the portion of a process’ memory that is used for data
that lives beyond the lifetime of any one function or method. The
lifetime of this data is defined by when it is allocated and when the
heap manager either explicitly deletes it or garbage collects it.</p></li>
<li><p>Languages like C or C++ allocate chunks of memory manually through
explicit statements like malloc, free, new, delete, etc…</p></li>
<li><p>Languages like C# or Java allocate chunks of memory through
statements like new and deallocate memory with garbage collectors</p></li>
</ul>
</section>
<section id="the-memory-manager">
<h2>The Memory Manager<a class="headerlink" href="#the-memory-manager" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#the-memory-manager'">¶</a></h2>
<ul class="simple">
<li><p>The memory manager has the following responsibilities:</p>
<ul>
<li><p>Manages list of allocated sections of memory</p></li>
<li><p>Manages list of free regions in memory</p></li>
<li><p>Allocation - When a program manages memory for an object, the
memory manager will find a chunk of contiguous memory at least as
large as the object. If not enough contiguous memory is available,
it asks the operating system for more heap space</p></li>
<li><p>Deallocation - When a program deallocates heap memory, the memory
manager returns the deallocated space to the free list. Memory is
typically not returned to the operating system in most
implementations.</p></li>
</ul>
</li>
</ul>
</section>
<section id="characteristics-of-memory-allocation">
<h2>Characteristics of Memory Allocation<a class="headerlink" href="#characteristics-of-memory-allocation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#characteristics-of-memory-allocation'">¶</a></h2>
<ul class="simple">
<li><p>Requests from a program for chunks of the heap are typically not of
the same size</p></li>
<li><p>Deallocation is not predictable. In the stack, memory is allocated
and freed in First In Last Out order. This is not true of the heap.</p></li>
<li><p>Therefore, the memory manager must be prepared to handle requests of
differing size in unpredictable order</p></li>
<li><p>Most of the time, the majority of requests are for small regions of
memory that are measured in bytes or kilo-bytes.</p></li>
</ul>
</section>
<section id="id2">
<h2>Characteristics of Memory Allocation<a class="headerlink" href="#id2" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id2'">¶</a></h2>
<ul class="simple">
<li><p>Although not optimal, it is acceptable for an allocator to return a
region of memory larger than the requested size.</p></li>
<li><p>Many allocators will split the heap into buckets of a different chunk
sizes.</p></li>
<li><p>So, for example an allocator may service a request for 31 bytes of
memory with a region of memory that is 32 bytes in size.s</p></li>
</ul>
</section>
<section id="characteristics-of-a-good-memory-manager">
<h2>Characteristics of a Good Memory Manager<a class="headerlink" href="#characteristics-of-a-good-memory-manager" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#characteristics-of-a-good-memory-manager'">¶</a></h2>
<ul class="simple">
<li><p>Space Efficiency - The memory manager should minimize the total heap
needed by a program. This is accomplished by minimizing heap
fragmentation.</p></li>
<li><p>Program Efficiency - Allocations should be arranged in memory to
preserve locality</p></li>
<li><p>Low Overhead - Memory allocations / deallocations are frequent
operations in a program. Because of this, the overhead of the memory
manager should be minimized. Efficiency for smaller memory
allocations should be a priority over efficiency for larger
allocations since smaller allocations happen more frequently.</p></li>
</ul>
</section>
<section id="a-refresher-on-the-memory-hierarchy">
<h2>A Refresher on the Memory Hierarchy<a class="headerlink" href="#a-refresher-on-the-memory-hierarchy" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#a-refresher-on-the-memory-hierarchy'">¶</a></h2>
<ul class="simple">
<li><p>Memory Type / Memory Size / Access Time</p></li>
<li><p>Registers / 32 words / 1 ns</p></li>
<li><p>L1 Cache / 16 - 64KB / 5-10 ns</p></li>
<li><p>L2 Cache / 128KB - 4MB / 40-60 ns</p></li>
<li><p>Physical Memory / 512MB - 8GB / 100 - 150 ns</p></li>
<li><p>Swap File / 512MB - 8GB / 3 - 15 ms</p></li>
</ul>
</section>
<section id="program-locality">
<h2>Program Locality<a class="headerlink" href="#program-locality" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#program-locality'">¶</a></h2>
<ul class="simple">
<li><p>Often, programs contain many instructions that are never executed.</p></li>
<li><p>Programs built with reusable libraries, often only use a small
fraction of the capability of these libraries.</p></li>
<li><p>Programs typically spend most of their time executing innermost loops
and recursive functions.</p></li>
<li><p>Only a small fraction of code that could be executed is actually
executed. This means, that within any given method, there are basic
blocks of code dedicated to exception and error handling that is
often not invoked.</p></li>
</ul>
</section>
<section id="fragmentation">
<h2>Fragmentation<a class="headerlink" href="#fragmentation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#fragmentation'">¶</a></h2>
<ul class="simple">
<li><p>Internal fragmentation - When a request for memory is answered with a
region of memory that is larger than the request, the remainder is
wasted.</p></li>
<li><p>External fragmentation - Regions of contiguous memory that are not
large enough to service requests.</p></li>
<li><p>External fragmentation = 1 - (largest free region / total free
memory)</p></li>
<li><p>Fragmentation comes about because while decisions can be made about
where heap allocations are placed, the order of their eventual
deallocations cannot be controlled or predicted.</p></li>
</ul>
</section>
<section id="reducing-fragmentation-of-the-heap">
<h2>Reducing Fragmentation of the Heap<a class="headerlink" href="#reducing-fragmentation-of-the-heap" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#reducing-fragmentation-of-the-heap'">¶</a></h2>
<ul class="simple">
<li><p>The heap starts as one contiguous free space</p></li>
<li><p>As the program allocates and deallocates memory, the free space will
no longer be contiguous</p></li>
<li><p>After a while, there may be regions of free space that are not large
enough to service a memory allocation request.</p></li>
<li><p>If the free space becomes sufficiently fragmented, then it is
possible that even though there is enough total free memory, a
request for more memory could fail because there isn’t a contiguous
free region that is large enough.</p></li>
</ul>
</section>
<section id="best-fit-vs-next-fit">
<h2>Best-Fit vs Next-Fit<a class="headerlink" href="#best-fit-vs-next-fit" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#best-fit-vs-next-fit'">¶</a></h2>
<ul class="simple">
<li><p>The best-fit allocation policy is to fit each request into the free
memory region that is the smallest that will satisfy the request</p></li>
<li><p>The first-fit allocation policy is to fit each request into the first
free memory region encountered in a search that will satisfy the
request</p></li>
<li><p>Overall, the best-fit policy provides the best performance in most
cases.</p></li>
<li><p>The downside to the best-fit policy is that it results in a more
complex allocator and there is some cost to the search for the best
fitting free region (although there are ways around this).</p></li>
</ul>
</section>
<section id="best-fit">
<h2>Best-Fit<a class="headerlink" href="#best-fit" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#best-fit'">¶</a></h2>
<ul class="simple">
<li><p>To avoid the costs associated with searching for the best-fit free
space region for an allocation, best-fit allocators commonly will
split up the heap into different buckets.</p></li>
<li><p>Each of these buckets will be responsible for serving different sized
requests.</p></li>
<li><p>In the GNU Standard C Library, there are buckets of size 8-byte,
16-byte, 24-byte, …. 512-byte. For larger allocations, there are
additional buckets for sizes spread out logarithmically (512, 576,
640, ….)</p></li>
<li><p>To service an allocation request, the allocator will use the free
list in the bucket that is the smallest that is also the same size or
larger than the request. If that bucket is empty, then the next
largest one is used. If all buckets are full, then the allocator asks
the operating system for more heap space.</p></li>
</ul>
</section>
<section id="managing-free-space">
<h2>Managing Free Space<a class="headerlink" href="#managing-free-space" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#managing-free-space'">¶</a></h2>
<ul class="simple">
<li><p>There are three approaches to managing free space:</p>
<ul>
<li><p>If buckets are being used, then a bitmap of which items in each
bucket are free can be maintained. This is pretty straightforward.</p></li>
<li><p>Boundary Tags - At the high and low end of each chunk, we keep a
bit telling us if the chunk is free or allocated and how big the
chunk is</p></li>
<li><p>Doubly Linked, Embedded Free List - The free chunks contain
pointers to a previous free chunk and a next free chunk. Often
these lists are sorted to help best-fit algorithms.</p></li>
</ul>
</li>
</ul>
</section>
<section id="bugs-and-explicit-allocators">
<h2>Bugs and Explicit Allocators<a class="headerlink" href="#bugs-and-explicit-allocators" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#bugs-and-explicit-allocators'">¶</a></h2>
<ul class="simple">
<li><p>For languages like C, when programs write beyond the boundaries of
allocated sections of the memory explicitly allocated, it is possible
that these overwrites will write into structures used by the
allocator.</p></li>
<li><p>Because of this possibility, different allocators are more or less
susceptible to different types of errors. In general, Boundary Tags,
and Doubly Linked Embedded Free List are fairly vulnerable to these
types of bugs. Bucket allocators with bitmaps are less susceptible.</p></li>
<li><p>This reality can be of use during debugging. There are some
debug-only allocators that return extra large regions of memory for
each allocation and pad the front and back of each region. At
deallocation time, if the padded values are altered, then the
allocator can print an error to the console.</p></li>
</ul>
</section>
<section id="debugging-malloc-free">
<h2>Debugging malloc / free<a class="headerlink" href="#debugging-malloc-free" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#debugging-malloc-free'">¶</a></h2>
<ul class="simple">
<li><p>An excellent way to debug common malloc / free issues is to use the
dmalloc library.</p></li>
<li><p>This library is available at <a class="reference external" href="http://dmalloc.com">http://dmalloc.com</a>. It can be used in
existing applications without modification.</p></li>
<li><p>This library can help you discover:</p>
<ul>
<li><p>Where un-freed objects were originally allocated.</p></li>
<li><p>Where any buffer overruns are if they are encountered.</p></li>
</ul>
</li>
</ul>
</section>
<section id="expanding-the-heap">
<h2>Expanding the Heap<a class="headerlink" href="#expanding-the-heap" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#expanding-the-heap'">¶</a></h2>
<ul class="simple">
<li><p>There are two ways that UNIX allocators expand the heap:</p>
<ul>
<li><p>sbrk - Asks the OS to increase the data segment by N bytes.</p></li>
<li><p>mmap/mfree - Requests from the OS to allocate a separate
non-contiguous region of memory. Since these regions are
non-contiguous, it is simpler to return them to the OS. mmap/mfree
have a fairly large overhead. Often, mmap/mfree are used to
service requests for larger allocations that don’t fit into a
bucket (&gt; 1MB).</p></li>
</ul>
</li>
</ul>
</section>
<section id="recommended-reading">
<h2>Recommended Reading<a class="headerlink" href="#recommended-reading" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#recommended-reading'">¶</a></h2>
<ul class="simple">
<li><p>Article by Doug Lea, the author of the GNU libc malloc/realloc/free -
<a class="reference external" href="http://g.oswego.edu/dl/html/malloc.html">http://g.oswego.edu/dl/html/malloc.html</a></p></li>
</ul>
</section>
<section id="problems-with-manual-deallocation">
<h2>Problems with manual deallocation<a class="headerlink" href="#problems-with-manual-deallocation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#problems-with-manual-deallocation'">¶</a></h2>
<ul class="simple">
<li><p>Manual memory deallocation can lead to memory leaks. Memory leaks are
defined as memory that has been allocated, but not deallocated and
will not be referenced at any point in the future.</p></li>
<li><p>Memory leaks do not cause a program to be incorrect or to crash as
long as enough free memory is available. For short lived programs
this is not a problem. For longer lived programs this is a problem.</p></li>
</ul>
</section>
<section id="id3">
<h2>Problems with manual deallocation<a class="headerlink" href="#id3" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id3'">¶</a></h2>
<ul class="simple">
<li><p>Manual memory deallocation can lead to problems if after the
deallocation, a pointer refers to the deallocated space and the
program dereferences that pointer in the future. This can lead to
modification of memory that was allocated to different pointers or to
memory that has been released to the operating system. This can lead
to crashes or incorrect program behavior.</p></li>
</ul>
</section>
<section id="avoiding-problems-with-manual-deallocation">
<h2>Avoiding problems with manual deallocation<a class="headerlink" href="#avoiding-problems-with-manual-deallocation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#avoiding-problems-with-manual-deallocation'">¶</a></h2>
<ul class="simple">
<li><p>When designing an application, make sure each allocated object has a
defined owner. This can be an instance of a class, or a function.
This is applicable when the owner can be determined statically.</p></li>
<li><p>When the owner cannot be determined statically, using reference
counters is advisable. Whenever a reference to an object is created,
we increment the reference counter. Whenever a reference goes away,
we decrease the reference counter. When the counter reaches zero, we
deallocate the object. This runs into trouble with cyclic structures.</p></li>
</ul>
</section>
<section id="a-simple-malloc-free-implementation-example-from-ibm-developer-works">
<h2>A simple Malloc / Free Implementation (Example from IBM Developer Works)<a class="headerlink" href="#a-simple-malloc-free-implementation-example-from-ibm-developer-works" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#a-simple-malloc-free-implementation-example-from-ibm-developer-works'">¶</a></h2>
<p>{language=C, basicstyle=, indent=xleftmargin}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;unistd.h&gt;</span>
<span class="nb">int</span> <span class="n">has_initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">void</span> <span class="o">*</span><span class="n">managed_memory_start</span><span class="p">;</span>
<span class="n">void</span> <span class="o">*</span><span class="n">last_valid_address</span><span class="p">;</span>

<span class="n">struct</span> <span class="n">mem_control_block</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">is_available</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">malloc_init</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">last_valid_address</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">managed_memory_start</span> <span class="o">=</span> <span class="n">last_valid_address</span><span class="p">;</span>
   <span class="n">has_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="a-simple-malloc-free-implementation">
<h2>A simple Malloc / Free Implementation<a class="headerlink" href="#a-simple-malloc-free-implementation" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#a-simple-malloc-free-implementation'">¶</a></h2>
<p>{language=C, basicstyle=, indent=xleftmargin}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">myfree</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">firstbyte</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">struct</span> <span class="n">mem_control_block</span> <span class="o">*</span><span class="n">mcb</span><span class="p">;</span>
  <span class="n">mcb</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">mem_control_block</span><span class="o">*</span><span class="p">)</span>
           <span class="p">(</span><span class="n">firstbyte</span> <span class="o">-</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">mem_control_block</span><span class="p">));</span>
  <span class="n">mcb</span><span class="o">-&gt;</span><span class="n">is_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id4">
<h2>A simple Malloc / Free Implementation<a class="headerlink" href="#id4" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id4'">¶</a></h2>
<p>{language=C, basicstyle=, indent=xleftmargin}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void *mymalloc(long numbytes) {
  void *current_location;
  struct mem_control_block *current_location_mcb;
  void *memory_location;
  if(! has_initialized)   {
    malloc_init();
  }
  numbytes = numbytes + sizeof(struct mem_control_block);
  memory_location = 0;
  current_location = managed_memory_start;
</pre></div>
</div>
</section>
<section id="id5">
<h2>A simple Malloc / Free Implementation<a class="headerlink" href="#id5" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id5'">¶</a></h2>
<p>{language=C, basicstyle=, indent=xleftmargin}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">current_location</span> <span class="o">!=</span> <span class="n">last_valid_address</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">current_location_mcb</span> <span class="o">=</span>
         <span class="p">(</span><span class="n">struct</span> <span class="n">mem_control_block</span> <span class="o">*</span><span class="p">)</span><span class="n">current_location</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">current_location_mcb</span><span class="o">-&gt;</span><span class="n">is_available</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">current_location_mcb</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">numbytes</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">current_location_mcb</span><span class="o">-&gt;</span><span class="n">is_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">memory_location</span> <span class="o">=</span> <span class="n">current_location</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">current_location</span> <span class="o">=</span> <span class="n">current_location</span> <span class="o">+</span>
                    <span class="n">current_location_mcb</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id6">
<h2>A simple Malloc / Free Implementation<a class="headerlink" href="#id6" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id6'">¶</a></h2>
<p>{language=C, basicstyle=, indent=xleftmargin}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  if(!memory_location)
  {
    sbrk(numbytes);
    memory_location = last_valid_address;
    last_valid_address = last_valid_address + numbytes;
    current_location_mcb =
               (struct mem_control_block*)memory_location;
    current_location_mcb-&gt;is_available = 0;
    current_location_mcb-&gt;size = numbytes;
  }
  memory_location = memory_location +
              sizeof(struct mem_control_block);
  return memory_location;
}
</pre></div>
</div>
</section>
<section id="garbage-collection">
<h2>Garbage Collection<a class="headerlink" href="#garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#garbage-collection'">¶</a></h2>
</section>
<section id="id7">
<h2>Garbage Collection<a class="headerlink" href="#id7" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id7'">¶</a></h2>
<ul class="simple">
<li><p>Data that can’t be referenced is considered garbage</p></li>
<li><p>One problem that explicit allocators have is that deallocation is the
source of bugs</p></li>
<li><p>Some runtimes and programming languages provide automatic garbage
collectors.</p></li>
<li><p>The first garbage collector implementation was for the LISP
programming language in 1958.</p></li>
</ul>
</section>
<section id="requirements-for-garbage-collectors">
<h2>Requirements for Garbage Collectors<a class="headerlink" href="#requirements-for-garbage-collectors" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#requirements-for-garbage-collectors'">¶</a></h2>
<ul class="simple">
<li><p>Most garbage collectors require that a system be type safe to support
a collector.</p></li>
<li><p>Most garbage collectors require that references / pointers refer to
the beginning of an object and not somewhere in the middle</p></li>
<li><p>In general, these guarantees cannot be made for C programs.</p></li>
<li><p>Garbage collectors exist for C, but programmers have to limit their
use of the full capability of C</p></li>
</ul>
</section>
<section id="goals-for-a-garbage-collector">
<h2>Goals for a Garbage Collector<a class="headerlink" href="#goals-for-a-garbage-collector" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#goals-for-a-garbage-collector'">¶</a></h2>
<ul class="simple">
<li><p>Overall execution time for collection - Garbage collectors must
access a lot of data. The faster they are the better</p></li>
<li><p>Space Usage - Garbage collectors must keep fragmentation to a minimum</p></li>
<li><p>Wait time - Many garbage collectors require that a program be
temporarily halted while running. So, it is desirable that the
maximum wait time be small.</p></li>
<li><p>Locality - Like explicit allocators, garbage collectors can help
preserve locality by allocating memory from regions that are recently
deallocated.</p></li>
</ul>
</section>
<section id="disadvantages-to-garbage-collection">
<h2>Disadvantages to Garbage Collection<a class="headerlink" href="#disadvantages-to-garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#disadvantages-to-garbage-collection'">¶</a></h2>
<ul class="simple">
<li><p>Garbage collectors consume processing time determining which objects
are garbage</p></li>
<li><p>Garbage collectors run interval is not predictable. This can cause
trouble for:</p>
<ul>
<li><p>The garbage collector may run too late, allowing too much garbage
to pile up</p></li>
<li><p>Garbage collectors need to halt execution to one degree or
another. This can degrade performance.</p></li>
</ul>
</li>
</ul>
</section>
<section id="id8">
<h2>Disadvantages to Garbage Collection<a class="headerlink" href="#id8" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id8'">¶</a></h2>
<ul class="simple">
<li><p>Garbage collectors can’t detect when low physical memory conditions
occur. With manual deallocation, the memory usage should always be
the minimum needed, but with garbage collectors, this can be
variable. So, it is possible that a garbage collector can encourage
overuse of physical memory or unnecessary paging.</p></li>
<li><p>Garbage collectors cannot remove all possible memory leaks. Garbage
collectors can only collect garbage.</p></li>
</ul>
</section>
<section id="reachability">
<h2>Reachability<a class="headerlink" href="#reachability" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#reachability'">¶</a></h2>
<ul class="simple">
<li><p>Every program has a concept of a root set of references. The root set
is the list of references held on the stack of every executing
thread.</p></li>
<li><p>Some programming language and compiler support is required to make
sure that this list is available to the garbage collector.</p></li>
<li><p>Operations that change reachability:</p>
<ul>
<li><p>Allocations - allocating new objects create new reachable objects</p></li>
<li><p>Method “out” parameters and return values - Values returned from
allocations within a method remain reachable by the caller</p></li>
<li><p>Reference copying - Copying a reference from one reference
variable to another.</p></li>
<li><p>Method returns - When a method returns, all of the references on
the stack that are not a part of the return are lost.</p></li>
</ul>
</li>
</ul>
</section>
<section id="reference-counting-garbage-collectors">
<h2>Reference Counting Garbage Collectors<a class="headerlink" href="#reference-counting-garbage-collectors" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#reference-counting-garbage-collectors'">¶</a></h2>
<ul class="simple">
<li><p>Reference counting garbage collectors work by detecting when an
object’s reference count reaches zero and at that time deallocate the
object. References are increased and decreased in the following
manner:</p>
<ul>
<li><p>Allocation - New objects start with a reference count of 1</p></li>
<li><p>Parameter passing - when a parameter is passed to a method, it’s
reference count is incremented</p></li>
<li><p>Reference assignments - If a copy of the reference is made, the
reference count goes up by 1</p></li>
<li><p>Method returns - when a method returns, all references on that
method’s stack have their counts decremented by 1</p></li>
<li><p>Transitive - if a reference count of an object reaches 0, then it
also decrements the reference of every object it refers to.</p></li>
</ul>
</li>
</ul>
</section>
<section id="pros-cons-of-reference-counting-garbage-collectors">
<h2>Pros-Cons of Reference Counting Garbage Collectors<a class="headerlink" href="#pros-cons-of-reference-counting-garbage-collectors" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#pros-cons-of-reference-counting-garbage-collectors'">¶</a></h2>
<ul class="simple">
<li><p>Pros</p>
<ul>
<li><p>The implementation is very simple.</p></li>
</ul>
</li>
<li><p>Cons</p>
<ul>
<li><p>There is a lot of book keeping overhead. Every time a method is
called and returned from, each parameter and stack variable has to
be touched an additional time.</p></li>
<li><p>Reference counting cannot collect unreachable, cyclic data
structures.</p></li>
</ul>
</li>
</ul>
</section>
<section id="mark-and-sweep-garbage-collection">
<h2>Mark-and-Sweep Garbage Collection<a class="headerlink" href="#mark-and-sweep-garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#mark-and-sweep-garbage-collection'">¶</a></h2>
<ul class="simple">
<li><p>Mark-and-Sweep collectors work by stopping the execution of a program
and use an algorithm to determine which objects are not reachable and
return those unreachable objects to the free list.</p></li>
<li><p>The algorithm works by maintaining four sets</p>
<ul>
<li><p>The free list - a list of free memory regions</p></li>
<li><p>The root set - a list of all references on the stacks of all
executing threads and global variables.</p></li>
<li><p>The referenced list - a list of objects that are referenced.</p></li>
<li><p>The unscanned list - a list of allocated objects that have not yet
been found to be referenced.</p></li>
</ul>
</li>
<li><p>The algorithm then does a depth first search form all items in the
root set. If an item is reached in the scan, it is removed from the
unscanned list to the referenced list.</p></li>
<li><p>After the scan is complete, items remaining in the unscanned list are
moved to the free list as garbage.</p></li>
</ul>
</section>
<section id="mark-and-compact-garbage-collection">
<h2>Mark-and-Compact Garbage Collection<a class="headerlink" href="#mark-and-compact-garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#mark-and-compact-garbage-collection'">¶</a></h2>
<ul class="simple">
<li><p>Compacting garbage collectors take the additional step of moving
objects around in memory after collection to make free space
contiguous and to make allocated objects closer to each other in
memory.</p></li>
<li><p>The most popular type of these collectors are copying collectors.</p></li>
<li><p>Copying collectors modify the Mark-and-Sweep collector algorithm by
performing a copy operation to a contiguous free memory region that
is set aside at collection time instead of adding the objects to the
referenced list. Then, after collection is complete, the previous
memory region becomes the free memory region.</p></li>
<li><p>For more details, see “Cheney’s Algorithm” in a paper by C.J. Cheney
in the ACM library.</p></li>
</ul>
</section>
<section id="garbage-collection-costs">
<h2>Garbage Collection Costs<a class="headerlink" href="#garbage-collection-costs" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#garbage-collection-costs'">¶</a></h2>
<ul class="simple">
<li><p>Mark-and-Sweep collectors costs are related to the number of
reachable objects</p></li>
<li><p>Compacting (Copying) collectors costs are related to the total size
of reachable objects.</p></li>
</ul>
</section>
<section id="incremental-garbage-collection">
<h2>Incremental Garbage Collection<a class="headerlink" href="#incremental-garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#incremental-garbage-collection'">¶</a></h2>
<ul class="simple">
<li><p>The previously mentioned garbage collectors stop the execution of all
threads in a program to run. This can cause programs to pause for
long periods of time.</p></li>
<li><p>To keep programs responsive, incremental garbage collection is
desirable.</p></li>
<li><p>Instead of collecting all garbage, incremental garbage collectors
just collect objects that can be found to be unreachable without
performing a mark and sweep algorithm.</p></li>
<li><p>Then, in subsequent collections, the collector will be able to
collect objects that became unreachable by the previous collection in
addition to any newly unreachable objects.</p></li>
</ul>
</section>
<section id="id9">
<h2>Incremental Garbage Collection<a class="headerlink" href="#id9" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id9'">¶</a></h2>
<ul class="simple">
<li><p>Why in general do incremental garbage collectors work well?</p></li>
<li><p>For most programs, objects become garbage rapidly. This means that
most allocations in a program become unreferenced fairly soon after
being allocated.</p></li>
<li><p>Often, the number of objects that become garbage rapidly is in the
range of 80 - 95 percent. These objects are typically easily
collected and at a high rate by an incremental garbage collector</p></li>
<li><p>The downside is that, very often an object that survives a first
round of incremental collection, will often survive more than one
round. In copying incremental collectors, this means that they will
also be copied multiple times.</p></li>
</ul>
</section>
<section id="generational-garbage-collection">
<h2>Generational Garbage Collection<a class="headerlink" href="#generational-garbage-collection" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#generational-garbage-collection'">¶</a></h2>
<ul class="simple">
<li><p>Generational garbage collectors are a specific way of implementing a
copying incremental garbage collector.</p></li>
<li><p>Generational collectors split the heap into N sections. Section 0 is
the oldest, 1 is the next oldest, ….</p></li>
<li><p>When section 0 becomes full, then the collector is invoked and copies
reachable objects into section 1, making the entire section 0 free.</p></li>
<li><p>When any 1…N section becomes full, the same algorithm takes place.</p></li>
<li><p>Occasionally, garbage collection is run for some value of i between 1
and N to free objects in sections 1…N.</p></li>
<li><p>This type of collection is very fast because it favors scanning young
objects which are objects most likely to be garbage.</p></li>
</ul>
</section>
<section id="id10">
<h2>Generational Garbage Collection<a class="headerlink" href="#id10" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#id10'">¶</a></h2>
<ul class="simple">
<li><p>Generational garbage collectors are used in many platforms -</p></li>
<li><p>Java</p></li>
<li><p>.NET</p></li>
<li><p>Python</p></li>
</ul>
</section>
<section id="buyer-beware">
<h2>Buyer Beware<a class="headerlink" href="#buyer-beware" title="Link to this heading" x-intersect.margin.0%.0%.-70%.0%="activeSection = '#buyer-beware'">¶</a></h2>
<ul class="simple">
<li><p>Even with advanced and efficient garbage collection algorithms, it is
still possible in theory to “leak” memory.</p></li>
<li><p>Programs that have poorly defined object lifetimes or hang on to
references for too long can accumulate objects that will never be
referenced in the future.</p></li>
<li><p>Programs like these will slowly run out of memory without creating
any garbage for the collector to reclaim.</p></li>
<li><p>It is also important to remember that with incremental / generational
collectors, not all garbage is collected every time. Also some of
these collectors will never reclaim large objects (greater than 8KB)
due to the cost. It is possible in these systems to run out of memory
artificially.</p></li>
</ul>
</section>
</section>
</div></div><aside class="hidden text-sm xl:block" id="right-sidebar">
<div class="sticky top-16 -mt-10 max-h-[calc(var(--vh)-4rem)] overflow-y-auto pt-6 space-y-2"><p class="font-medium">On this page</p>
<ul>
<li><a :data-current="activeSection === '#why-userland-memory-management'" class="reference internal" href="#why-userland-memory-management">Why Userland Memory Management?</a></li>
<li><a :data-current="activeSection === '#id1'" class="reference internal" href="#id1">Why Userland Memory Management?</a></li>
<li><a :data-current="activeSection === '#heap-management'" class="reference internal" href="#heap-management">Heap Management</a></li>
<li><a :data-current="activeSection === '#the-heap'" class="reference internal" href="#the-heap">The Heap</a></li>
<li><a :data-current="activeSection === '#the-memory-manager'" class="reference internal" href="#the-memory-manager">The Memory Manager</a></li>
<li><a :data-current="activeSection === '#characteristics-of-memory-allocation'" class="reference internal" href="#characteristics-of-memory-allocation">Characteristics of Memory Allocation</a></li>
<li><a :data-current="activeSection === '#id2'" class="reference internal" href="#id2">Characteristics of Memory Allocation</a></li>
<li><a :data-current="activeSection === '#characteristics-of-a-good-memory-manager'" class="reference internal" href="#characteristics-of-a-good-memory-manager">Characteristics of a Good Memory Manager</a></li>
<li><a :data-current="activeSection === '#a-refresher-on-the-memory-hierarchy'" class="reference internal" href="#a-refresher-on-the-memory-hierarchy">A Refresher on the Memory Hierarchy</a></li>
<li><a :data-current="activeSection === '#program-locality'" class="reference internal" href="#program-locality">Program Locality</a></li>
<li><a :data-current="activeSection === '#fragmentation'" class="reference internal" href="#fragmentation">Fragmentation</a></li>
<li><a :data-current="activeSection === '#reducing-fragmentation-of-the-heap'" class="reference internal" href="#reducing-fragmentation-of-the-heap">Reducing Fragmentation of the Heap</a></li>
<li><a :data-current="activeSection === '#best-fit-vs-next-fit'" class="reference internal" href="#best-fit-vs-next-fit">Best-Fit vs Next-Fit</a></li>
<li><a :data-current="activeSection === '#best-fit'" class="reference internal" href="#best-fit">Best-Fit</a></li>
<li><a :data-current="activeSection === '#managing-free-space'" class="reference internal" href="#managing-free-space">Managing Free Space</a></li>
<li><a :data-current="activeSection === '#bugs-and-explicit-allocators'" class="reference internal" href="#bugs-and-explicit-allocators">Bugs and Explicit Allocators</a></li>
<li><a :data-current="activeSection === '#debugging-malloc-free'" class="reference internal" href="#debugging-malloc-free">Debugging malloc / free</a></li>
<li><a :data-current="activeSection === '#expanding-the-heap'" class="reference internal" href="#expanding-the-heap">Expanding the Heap</a></li>
<li><a :data-current="activeSection === '#recommended-reading'" class="reference internal" href="#recommended-reading">Recommended Reading</a></li>
<li><a :data-current="activeSection === '#problems-with-manual-deallocation'" class="reference internal" href="#problems-with-manual-deallocation">Problems with manual deallocation</a></li>
<li><a :data-current="activeSection === '#id3'" class="reference internal" href="#id3">Problems with manual deallocation</a></li>
<li><a :data-current="activeSection === '#avoiding-problems-with-manual-deallocation'" class="reference internal" href="#avoiding-problems-with-manual-deallocation">Avoiding problems with manual deallocation</a></li>
<li><a :data-current="activeSection === '#a-simple-malloc-free-implementation-example-from-ibm-developer-works'" class="reference internal" href="#a-simple-malloc-free-implementation-example-from-ibm-developer-works">A simple Malloc / Free Implementation (Example from IBM Developer Works)</a></li>
<li><a :data-current="activeSection === '#a-simple-malloc-free-implementation'" class="reference internal" href="#a-simple-malloc-free-implementation">A simple Malloc / Free Implementation</a></li>
<li><a :data-current="activeSection === '#id4'" class="reference internal" href="#id4">A simple Malloc / Free Implementation</a></li>
<li><a :data-current="activeSection === '#id5'" class="reference internal" href="#id5">A simple Malloc / Free Implementation</a></li>
<li><a :data-current="activeSection === '#id6'" class="reference internal" href="#id6">A simple Malloc / Free Implementation</a></li>
<li><a :data-current="activeSection === '#garbage-collection'" class="reference internal" href="#garbage-collection">Garbage Collection</a></li>
<li><a :data-current="activeSection === '#id7'" class="reference internal" href="#id7">Garbage Collection</a></li>
<li><a :data-current="activeSection === '#requirements-for-garbage-collectors'" class="reference internal" href="#requirements-for-garbage-collectors">Requirements for Garbage Collectors</a></li>
<li><a :data-current="activeSection === '#goals-for-a-garbage-collector'" class="reference internal" href="#goals-for-a-garbage-collector">Goals for a Garbage Collector</a></li>
<li><a :data-current="activeSection === '#disadvantages-to-garbage-collection'" class="reference internal" href="#disadvantages-to-garbage-collection">Disadvantages to Garbage Collection</a></li>
<li><a :data-current="activeSection === '#id8'" class="reference internal" href="#id8">Disadvantages to Garbage Collection</a></li>
<li><a :data-current="activeSection === '#reachability'" class="reference internal" href="#reachability">Reachability</a></li>
<li><a :data-current="activeSection === '#reference-counting-garbage-collectors'" class="reference internal" href="#reference-counting-garbage-collectors">Reference Counting Garbage Collectors</a></li>
<li><a :data-current="activeSection === '#pros-cons-of-reference-counting-garbage-collectors'" class="reference internal" href="#pros-cons-of-reference-counting-garbage-collectors">Pros-Cons of Reference Counting Garbage Collectors</a></li>
<li><a :data-current="activeSection === '#mark-and-sweep-garbage-collection'" class="reference internal" href="#mark-and-sweep-garbage-collection">Mark-and-Sweep Garbage Collection</a></li>
<li><a :data-current="activeSection === '#mark-and-compact-garbage-collection'" class="reference internal" href="#mark-and-compact-garbage-collection">Mark-and-Compact Garbage Collection</a></li>
<li><a :data-current="activeSection === '#garbage-collection-costs'" class="reference internal" href="#garbage-collection-costs">Garbage Collection Costs</a></li>
<li><a :data-current="activeSection === '#incremental-garbage-collection'" class="reference internal" href="#incremental-garbage-collection">Incremental Garbage Collection</a></li>
<li><a :data-current="activeSection === '#id9'" class="reference internal" href="#id9">Incremental Garbage Collection</a></li>
<li><a :data-current="activeSection === '#generational-garbage-collection'" class="reference internal" href="#generational-garbage-collection">Generational Garbage Collection</a></li>
<li><a :data-current="activeSection === '#id10'" class="reference internal" href="#id10">Generational Garbage Collection</a></li>
<li><a :data-current="activeSection === '#buyer-beware'" class="reference internal" href="#buyer-beware">Buyer Beware</a></li>
</ul>
</div>
</aside>
</main>
</div>
</div><footer class="py-6 border-t border-border md:py-0">
<div class="container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row">
<div class="flex flex-col items-center gap-4 px-8 md:flex-row md:gap-2 md:px-0">
<p class="text-sm leading-loose text-center text-muted-foreground md:text-left">© 2013-2020, Operating Systems Faculty at Loyola University Chicago Built with <a class="font-medium underline underline-offset-4" href="https://www.sphinx-doc.org" rel="noreferrer">Sphinx 7.2.6</a></p>
</div>
</div>
</footer>
</div>
</body>
</html>